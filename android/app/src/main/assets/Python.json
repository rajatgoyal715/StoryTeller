[
  {
    "link": "https://hackernoon.com/javascript-vs-python-in-2017-d31efbb641b4?source=---------0-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/0*SOeLg85_Q-vu1u80.jpg",
    "author": "",
    "date": "Mar 20",
    "photo": null,
    "head": "JavaScript vs. Python in 2017",
    "contents": "I may be one of the last people you would expect to write an essay criticizing JavaScript, but here we are. Two of my primary areas of professional interest are JavaScript and “programming in the large.” I gave a presentation back in 2013 at mloc.js where I argued that static typing is an essential feature when picking a language for a large software project. For this reason, among others, I historically limited my use of Python to small projects with no more than a handful of files. Recently, I needed to build a command-line tool for work that could speak Thrift. I have been enjoying the Nuclide/Flow/Babel/ESLint toolchain a lot recently, so my first instinct was to use JavaScript for this new project, as well. However, it quickly became clear that if I went that route, I would have to spend a lot of time up front on getting the Thrift bindings to work properly. I couldn’t convince myself that my personal preference for JavaScript would justify such an investment, so I decided to take a look at Python. I was vaguely aware that there was an effort to add support for static typing in Python, so I Googled to find out what the state of the art was. It turns out that it is a tool named Mypy, and it provides gradual typing, much like Flow does for JavaScript or Hack does for PHP. Fortunately, Mypy is more like Hack+HHVM than it is like Flow in that a Python 3 runtime accepts the type annotations natively whereas Flow type annotations must be stripped by a separate tool before passing the code to a JavaScript runtime. (To use Mypy in Python 2, you have to put your type annotations in comments, operating in the style of the Google Closure toolchain.) Although Mypy does not appear to be as mature as Flow (support for incremental type checking is still in the works, for example), simply being able to succinctly document type information was enough to renew my interest in Python. In researching how to use Thrift from Python, a Google search turned up some sample Python code that spoke to Thrift using asynchronous abstractions. After gradual typing, async/await is the other feature in JavaScript that I cannot live without, so this code sample caught my attention! As we recently added support for building projects in Python 3.6 at work, it was trivial for me to get up and running with the latest and greatest features in Python. (Incidentally, I also learned that you really want Python 3.6, not 3.5, as 3.6 has some important improvements to Mypy, fixes to the <a href=\"https://bugs.python.org/issue28613\" data-href=\"https://bugs.python.org/issue28613\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">asyncio</a> API, literal string interpolation like you have in ES6, and more!) Coming from the era of “modern” JavaScript, one thing that was particularly refreshing was rediscovering how Python is an edit/refresh language out of the box whereas JavaScript used to be that way, but is no more. Let me explain what I mean by that:Indeed, the JavaScript ecosystem offers all sorts of tools to speed up this process using daemons and caching, but you or someone on your team has to invest quite a bit of time researching, assembling, and maintaining a JavaScript toolchain for your project before anyone can write a line of “modern” JavaScript. Although you may ultimately achieve a nice edit/refresh workflow, you certainly will not have one out of the box as you would in Python.Another refreshing difference between JavaScript and Python is the “batteries included” nature of Python. If you look at the standard library that comes with JavaScript, it is fairly minimal. The Node environment does a modest job of augmenting what is provided by the standard library, but the majority of the functionality you need inevitably has to be fetched from npm. Specifically, consider the following functionality that is included in Python’s standard library, but must be fetched from npm for a Node project:As you can see, for many of these features, there are multiple third-party libraries that provide overlapping functionality. (For example, if you were looking for a JSON parser, would you choose parse-json, safe-json-parse, fast-json-parse, jsonparse, or json-parser?) To make matters worse, npm module names are doled out on a first-come, first-serve basis. Much like domain names, this means that great names often go to undeserving projects. (For example, judging from its download count, the npm module named <a href=\"https://www.npmjs.com/package/logging\" data-href=\"https://www.npmjs.com/package/logging\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">logging</a> makes it one of the least popular logging packages for JavaScript.) This makes the comparison of third-party modules all the more time-consuming since the quality of the name is not a useful signal for the quality of the library. It might be possible that Python&#39;s third-party ecosystem is just as bad as npm&#39;s. What is impressive is that I have no idea whether that is the case because it is so rare that I have to look to a third-party Python package to get the functionality that I need. I am aware that data scientists rely heavily on third-party packages like NumPy, but unlike the Node ecosystem, there is one NumPy package that everyone uses rather than a litany of competitors named numpy-fast, numpy-plus, simple-numpy, etc.For me, one of the great ironies in all this is that, arguably, the presence of a strong standard library in JavaScript would be the most highly leveraged when compared to other programming languages. Why? Because today, every non-trivial web site requires you to download underscore.js or whatever its authors have chosen to use to compensate for JavaScript’s weak core. When you consider the aggregate adverse impact this has on network traffic and page load times, the numbers are frightening.No, no I am not. If you are building UI using web technologies (which is a lot of developers), then I still think that JavaScript is your best bet. Modulo the emergence of Web Assembly (which is worth paying attention to), JavaScript is still the only language that runs natively in the browser. There have been many attempts to take an existing programming language and compile it to JavaScript to avoid “having to” write JavaScript. There are cases where the results were good, but they never seemed to be great. Maybe some transpilation toolchain will ultimately succeed in unseating JavaScript as the language to write in for the web, but I suspect we’ll still have the majority of web developers writing JavaScript for quite some time. Additionally, the browser is not the only place where developers are building UI using web technologies. Two other prominent examples are Electron and React Native. Electron is attractive because it lets you write once for Windows, Mac, and Linux while React Native is attractive because it lets you write once for Android and iOS. Both are also empowering because the edit/refresh cycles using those tools is much faster than their native equivalents. From a hiring perspective, it seems like developers who know web technologies (1) are available in greater numbers than native developers, and (2) can support more platforms with smaller teams compared to native developers. Indeed, I could envision ways in which these platforms could be modified to support Python as the scripting language instead of JavaScript, which could change the calculus. However, one thing that all of the crazy tooling that exists in the JavaScript community has given way to is transpiler toolchains like Babel, which make it easier for ordinary developers (who do not have to be compiler hackers) to experiment with new JavaScript syntax. In particular, this tooling has paved the way for things like JSX, which I contend is one of the key features that makes React such an enjoyable technology for building UI. (Note that you can use React without JSX, but it is tedious.) To the best of my knowledge, the Python community does not have an equivalent, popular mechanism for experimenting with DSLs within Python. So although it might be straightforward to add Python bindings in these existing environments, I do not think that would be sufficient to get product developers to switch to Python unless changes were also made to the language that made it as easy to express UI code in Python as it is in JavaScript+JSX today.Python 3.6 has built-in support for gradual typing and async/await. Unlike JavaScript, this means that you can write Python code that uses these language features and run that file directly without any additional tooling. Further, its rich standard library means that you have to spend little time fishing around and evaluating third-party libraries to fill in missing gaps. It is very much a “get stuff done” server-side scripting language, requiring far less scaffolding than JavaScript to get a project off the ground. Although Mypy may not be as featureful or performant as Flow or TypeScript is today, the velocity of that project is certainly something that I am going to start paying attention to. By comparison, I expect that JavaScript will remain strong among product developers, but those who use Node today for server-side code or command-line tools would probably be better off using Python. If the Node community wants to resist this change, then I think they would benefit from (1) expanding the Node API to make it more comprehensive, and (2) reducing the startup time for Node. It would be even better if they could modify their runtime to recognize things like type annotations and JSX natively, though that would require changes to V8 (or Chakra, on Windows), which I expect would be difficult to maintain and/or upstream. Getting TC39 to standardize either of those language features (which would force Google/Microsoft’s hand to add native support in their JS runtimes) also seems like a tough sell. Overall, I am excited to see how things play out in both of these communities. You never know when someone will release a new technology that obsoletes your entire toolchain overnight. For all I know, we might wake up tomorrow and all decide that we should be writing OCaml. Better set your alarm clock.This post originally appeared on bolinfest.com."
  },
  {
    "link": "https://hackernoon.com/docker-tutorial-getting-started-with-python-redis-and-nginx-81a9d740d091?source=---------1-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/1*7ji3NomsB-MG-9MadBD6hw.jpeg",
    "author": "Michael Bolin",
    "date": "Mar 24",
    "photo": "https://cdn-images-1.medium.com/max/800/0*-WxxLsxa6JCi8Aq_.png",
    "head": "Docker Tutorial — Getting Started with Python, Redis, and Nginx.",
    "contents": "I may be one of the last people you would expect to write an essay criticizing JavaScript, but here we are. Two of my primary areas of professional interest are JavaScript and “programming in the large.” I gave a presentation back in 2013 at mloc.js where I argued that static typing is an essential feature when picking a language for a large software project. For this reason, among others, I historically limited my use of Python to small projects with no more than a handful of files. Recently, I needed to build a command-line tool for work that could speak Thrift. I have been enjoying the Nuclide/Flow/Babel/ESLint toolchain a lot recently, so my first instinct was to use JavaScript for this new project, as well. However, it quickly became clear that if I went that route, I would have to spend a lot of time up front on getting the Thrift bindings to work properly. I couldn’t convince myself that my personal preference for JavaScript would justify such an investment, so I decided to take a look at Python. I was vaguely aware that there was an effort to add support for static typing in Python, so I Googled to find out what the state of the art was. It turns out that it is a tool named Mypy, and it provides gradual typing, much like Flow does for JavaScript or Hack does for PHP. Fortunately, Mypy is more like Hack+HHVM than it is like Flow in that a Python 3 runtime accepts the type annotations natively whereas Flow type annotations must be stripped by a separate tool before passing the code to a JavaScript runtime. (To use Mypy in Python 2, you have to put your type annotations in comments, operating in the style of the Google Closure toolchain.) Although Mypy does not appear to be as mature as Flow (support for incremental type checking is still in the works, for example), simply being able to succinctly document type information was enough to renew my interest in Python. In researching how to use Thrift from Python, a Google search turned up some sample Python code that spoke to Thrift using asynchronous abstractions. After gradual typing, async/await is the other feature in JavaScript that I cannot live without, so this code sample caught my attention! As we recently added support for building projects in Python 3.6 at work, it was trivial for me to get up and running with the latest and greatest features in Python. (Incidentally, I also learned that you really want Python 3.6, not 3.5, as 3.6 has some important improvements to Mypy, fixes to the <a href=\"https://bugs.python.org/issue28613\" data-href=\"https://bugs.python.org/issue28613\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">asyncio</a> API, literal string interpolation like you have in ES6, and more!) Coming from the era of “modern” JavaScript, one thing that was particularly refreshing was rediscovering how Python is an edit/refresh language out of the box whereas JavaScript used to be that way, but is no more. Let me explain what I mean by that:Indeed, the JavaScript ecosystem offers all sorts of tools to speed up this process using daemons and caching, but you or someone on your team has to invest quite a bit of time researching, assembling, and maintaining a JavaScript toolchain for your project before anyone can write a line of “modern” JavaScript. Although you may ultimately achieve a nice edit/refresh workflow, you certainly will not have one out of the box as you would in Python.Another refreshing difference between JavaScript and Python is the “batteries included” nature of Python. If you look at the standard library that comes with JavaScript, it is fairly minimal. The Node environment does a modest job of augmenting what is provided by the standard library, but the majority of the functionality you need inevitably has to be fetched from npm. Specifically, consider the following functionality that is included in Python’s standard library, but must be fetched from npm for a Node project:As you can see, for many of these features, there are multiple third-party libraries that provide overlapping functionality. (For example, if you were looking for a JSON parser, would you choose parse-json, safe-json-parse, fast-json-parse, jsonparse, or json-parser?) To make matters worse, npm module names are doled out on a first-come, first-serve basis. Much like domain names, this means that great names often go to undeserving projects. (For example, judging from its download count, the npm module named <a href=\"https://www.npmjs.com/package/logging\" data-href=\"https://www.npmjs.com/package/logging\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">logging</a> makes it one of the least popular logging packages for JavaScript.) This makes the comparison of third-party modules all the more time-consuming since the quality of the name is not a useful signal for the quality of the library. It might be possible that Python&#39;s third-party ecosystem is just as bad as npm&#39;s. What is impressive is that I have no idea whether that is the case because it is so rare that I have to look to a third-party Python package to get the functionality that I need. I am aware that data scientists rely heavily on third-party packages like NumPy, but unlike the Node ecosystem, there is one NumPy package that everyone uses rather than a litany of competitors named numpy-fast, numpy-plus, simple-numpy, etc.For me, one of the great ironies in all this is that, arguably, the presence of a strong standard library in JavaScript would be the most highly leveraged when compared to other programming languages. Why? Because today, every non-trivial web site requires you to download underscore.js or whatever its authors have chosen to use to compensate for JavaScript’s weak core. When you consider the aggregate adverse impact this has on network traffic and page load times, the numbers are frightening.No, no I am not. If you are building UI using web technologies (which is a lot of developers), then I still think that JavaScript is your best bet. Modulo the emergence of Web Assembly (which is worth paying attention to), JavaScript is still the only language that runs natively in the browser. There have been many attempts to take an existing programming language and compile it to JavaScript to avoid “having to” write JavaScript. There are cases where the results were good, but they never seemed to be great. Maybe some transpilation toolchain will ultimately succeed in unseating JavaScript as the language to write in for the web, but I suspect we’ll still have the majority of web developers writing JavaScript for quite some time. Additionally, the browser is not the only place where developers are building UI using web technologies. Two other prominent examples are Electron and React Native. Electron is attractive because it lets you write once for Windows, Mac, and Linux while React Native is attractive because it lets you write once for Android and iOS. Both are also empowering because the edit/refresh cycles using those tools is much faster than their native equivalents. From a hiring perspective, it seems like developers who know web technologies (1) are available in greater numbers than native developers, and (2) can support more platforms with smaller teams compared to native developers. Indeed, I could envision ways in which these platforms could be modified to support Python as the scripting language instead of JavaScript, which could change the calculus. However, one thing that all of the crazy tooling that exists in the JavaScript community has given way to is transpiler toolchains like Babel, which make it easier for ordinary developers (who do not have to be compiler hackers) to experiment with new JavaScript syntax. In particular, this tooling has paved the way for things like JSX, which I contend is one of the key features that makes React such an enjoyable technology for building UI. (Note that you can use React without JSX, but it is tedious.) To the best of my knowledge, the Python community does not have an equivalent, popular mechanism for experimenting with DSLs within Python. So although it might be straightforward to add Python bindings in these existing environments, I do not think that would be sufficient to get product developers to switch to Python unless changes were also made to the language that made it as easy to express UI code in Python as it is in JavaScript+JSX today.Python 3.6 has built-in support for gradual typing and async/await. Unlike JavaScript, this means that you can write Python code that uses these language features and run that file directly without any additional tooling. Further, its rich standard library means that you have to spend little time fishing around and evaluating third-party libraries to fill in missing gaps. It is very much a “get stuff done” server-side scripting language, requiring far less scaffolding than JavaScript to get a project off the ground. Although Mypy may not be as featureful or performant as Flow or TypeScript is today, the velocity of that project is certainly something that I am going to start paying attention to. By comparison, I expect that JavaScript will remain strong among product developers, but those who use Node today for server-side code or command-line tools would probably be better off using Python. If the Node community wants to resist this change, then I think they would benefit from (1) expanding the Node API to make it more comprehensive, and (2) reducing the startup time for Node. It would be even better if they could modify their runtime to recognize things like type annotations and JSX natively, though that would require changes to V8 (or Chakra, on Windows), which I expect would be difficult to maintain and/or upstream. Getting TC39 to standardize either of those language features (which would force Google/Microsoft’s hand to add native support in their JS runtimes) also seems like a tough sell. Overall, I am excited to see how things play out in both of these communities. You never know when someone will release a new technology that obsoletes your entire toolchain overnight. For all I know, we might wake up tomorrow and all decide that we should be writing OCaml. Better set your alarm clock.This post originally appeared on bolinfest.com.Docker is an open source tool that automates the deployment of the application inside software container. The easiest way to get the idea behind Docker is to compare it to, well… standard shipping containers.Back in the days, transportation companies faced the following challenges:With the introduction of containers, bricks can be put over glass, and chemicals can be stored next to food. Cargo of the various size can be put inside a standardized container that can be loaded/unloaded by the same vehicle.Let’s go back to containers in software development.When you develop an application, you need to provide your code alongside with all possible dependencies like libraries, web server, databases, etc. You may end up in a situation when the application is working on your computer but won’t even start on stage server, dev or a QA’s machine.This challenge can be addressed by isolating the app to make it independent of the system.Traditionally virtual machines were used to avoid this unexpected behavior. The main problem with VM is that “extra OS” on top of the host operating system adds gigabytes of space to the project. Most of the time your server will host several VMs that will take even more space. And by the way, at the moment most cloud-based server providers will charge you for that extra space. Another significant drawback of VM is a slow boot.Docker eliminates all the above by simply sharing OS kernel across all the containers that are running as separate processes of the host OS.Keep in mind that Docker is not the first and not the only containerization platform. However, at the moment Docker is the biggest and the most powerful player on the market.The list of benefits is the following:Docker’s native platform is Linux, as it’s based on features provided by Linux kernel. However, you can still run it on macOS and Windows. The only difference is that on macOS and Windows Docker is encapsulated into a tiny virtual machine. At the moment Docker for macOS and Windows has reached a significant level of usability and feels more like a native app.Moreover, there a lot of supplementary apps such as Kitematic or Docker Machine which help to install and operate Docker on non Linux platforms.You can check the installation instructions here. If you’re running Docker on Linux you need to run all the following commands as root or you can add your user to docker group and re-login:It’s time to run your first container:Console output:Let’s try to create an interactive shell inside Docker container:If you want to keep container running after the end of the session, you need to daemonize it:Let’s see what containers we have at the moment:Console output:The ps shows us that we have two containers:Note: there is no second container (the one with interactive shell) because we set — rm option. As a result, this container is automatically deleted right after execution.Let’s check the logs and see what daemon container is doing right now:Console output:Now let’s stop daemon container:Let’s make sure that the container has stopped.Console output:The container is stopped. We can start it again:Let’s ensure that it is running:Console output:Now let’s stop it again and remove all the containers manually:To remove all containers we can use the following command:Starting from this example you’ll need several additional files you can find on my GitHub repo. You can clone my repo or simply use the following link to download the sample files.It is time to create and run more meaningful container like Nginx.Change the directory to examples/nginx.Console output:Important: run command accepts only absolute paths. In our example we’ve used $(pwd) to set current directory absolute path.Now you can check this url in your web browser.We can try to change /example/nginx/index.html (which is mounted as a volume to/usr/share/nginx/html directory inside the container) and refresh the page.Let’s get the information about test-nginx container:This command displays system wide information about the Docker installation. This information includes the kernel version, number of containers and images, exposed ports, mounted volumes, etc.To build a Docker image you need to create a Dockerfile. It is a plain text file with instructions and arguments. Here is the description of the instructions we’re going to use in our next example:You can check Dockerfile reference for more details.Let’s create an image that will get the contents of the website with curl and store it to the text file. We need to pass website url via environment variable SITE_URL. Resulting file will be placed in a directory mounted as a volume.Dockerfile is ready, it’s time to build the actual image.Go to examples/curl and execute the following command to build an image:Console output:Now we have the new image and we can see it in the list of existing images:Console output:We can create and run container from the image. Let’s try it with default parameters:To see results saved to file run:Let’s try with facebook.com:To see results saved to file run:Docker compose — is the only right way to connect containers with each other.In this example, I am going to connect Python and Redis containers.Go to examples/compose and execute the following command:Console output:Current example will increment view counter in Redis. Open the following url in your web browser and check it.Using docker-compose is a topic for a separate article. To get started you can play with some images from Docker Hub or if you want to create your own images — follow best practices listed above. The only thing I can add in terms of using docker-compose: always give explicit names to your volumes in docker-compose.yml (if image has volumes). This simple rule will save you from issue in the future when you’ll be inspecting your volumes.In this case redis_data will be the name inside docker-compose.yml file, for the real volume name it will be prepended with project name prefix.To see volumes run:Console output:Without explicit volume name there will be UUID. And here is an example from my local machine:Docker has some restrictions and requirements depending on the architecture of your system (applications that you pack into containers). You can ignore these requirements or find some workarounds, but in this case, you won’t get all the benefits from using Docker. My strong advice is to follow these recommendations:To summarize all the above, alongside with IDE and Git, Docker has become one of the must-have developer tools.We at Django Stars have successfully implemented Docker in numerous projects. Stay tuned if you are interested in such advanced tutorials — “How to set up Django app in Docker?” and “How to use Docker and CircleCI?”.H ave you already used Docker on your project? Leave us a comment or ask questions below!"
  },
  {
    "link": "https://medium.com/xo-tech/from-node-to-go-a-high-level-comparison-56c8b717324a?source=---------2-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/0*fhDj65OfFxJ7vrOM.",
    "author": "",
    "date": "Mar 21",
    "photo": "https://cdn-images-1.medium.com/max/800/0*k9xE1bfJDWz4P19g.",
    "head": "From Node to Go: A High-Level Comparison",
    "contents": "I may be one of the last people you would expect to write an essay criticizing JavaScript, but here we are. Two of my primary areas of professional interest are JavaScript and “programming in the large.” I gave a presentation back in 2013 at mloc.js where I argued that static typing is an essential feature when picking a language for a large software project. For this reason, among others, I historically limited my use of Python to small projects with no more than a handful of files. Recently, I needed to build a command-line tool for work that could speak Thrift. I have been enjoying the Nuclide/Flow/Babel/ESLint toolchain a lot recently, so my first instinct was to use JavaScript for this new project, as well. However, it quickly became clear that if I went that route, I would have to spend a lot of time up front on getting the Thrift bindings to work properly. I couldn’t convince myself that my personal preference for JavaScript would justify such an investment, so I decided to take a look at Python. I was vaguely aware that there was an effort to add support for static typing in Python, so I Googled to find out what the state of the art was. It turns out that it is a tool named Mypy, and it provides gradual typing, much like Flow does for JavaScript or Hack does for PHP. Fortunately, Mypy is more like Hack+HHVM than it is like Flow in that a Python 3 runtime accepts the type annotations natively whereas Flow type annotations must be stripped by a separate tool before passing the code to a JavaScript runtime. (To use Mypy in Python 2, you have to put your type annotations in comments, operating in the style of the Google Closure toolchain.) Although Mypy does not appear to be as mature as Flow (support for incremental type checking is still in the works, for example), simply being able to succinctly document type information was enough to renew my interest in Python. In researching how to use Thrift from Python, a Google search turned up some sample Python code that spoke to Thrift using asynchronous abstractions. After gradual typing, async/await is the other feature in JavaScript that I cannot live without, so this code sample caught my attention! As we recently added support for building projects in Python 3.6 at work, it was trivial for me to get up and running with the latest and greatest features in Python. (Incidentally, I also learned that you really want Python 3.6, not 3.5, as 3.6 has some important improvements to Mypy, fixes to the <a href=\"https://bugs.python.org/issue28613\" data-href=\"https://bugs.python.org/issue28613\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">asyncio</a> API, literal string interpolation like you have in ES6, and more!) Coming from the era of “modern” JavaScript, one thing that was particularly refreshing was rediscovering how Python is an edit/refresh language out of the box whereas JavaScript used to be that way, but is no more. Let me explain what I mean by that:Indeed, the JavaScript ecosystem offers all sorts of tools to speed up this process using daemons and caching, but you or someone on your team has to invest quite a bit of time researching, assembling, and maintaining a JavaScript toolchain for your project before anyone can write a line of “modern” JavaScript. Although you may ultimately achieve a nice edit/refresh workflow, you certainly will not have one out of the box as you would in Python.Another refreshing difference between JavaScript and Python is the “batteries included” nature of Python. If you look at the standard library that comes with JavaScript, it is fairly minimal. The Node environment does a modest job of augmenting what is provided by the standard library, but the majority of the functionality you need inevitably has to be fetched from npm. Specifically, consider the following functionality that is included in Python’s standard library, but must be fetched from npm for a Node project:As you can see, for many of these features, there are multiple third-party libraries that provide overlapping functionality. (For example, if you were looking for a JSON parser, would you choose parse-json, safe-json-parse, fast-json-parse, jsonparse, or json-parser?) To make matters worse, npm module names are doled out on a first-come, first-serve basis. Much like domain names, this means that great names often go to undeserving projects. (For example, judging from its download count, the npm module named <a href=\"https://www.npmjs.com/package/logging\" data-href=\"https://www.npmjs.com/package/logging\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">logging</a> makes it one of the least popular logging packages for JavaScript.) This makes the comparison of third-party modules all the more time-consuming since the quality of the name is not a useful signal for the quality of the library. It might be possible that Python&#39;s third-party ecosystem is just as bad as npm&#39;s. What is impressive is that I have no idea whether that is the case because it is so rare that I have to look to a third-party Python package to get the functionality that I need. I am aware that data scientists rely heavily on third-party packages like NumPy, but unlike the Node ecosystem, there is one NumPy package that everyone uses rather than a litany of competitors named numpy-fast, numpy-plus, simple-numpy, etc.For me, one of the great ironies in all this is that, arguably, the presence of a strong standard library in JavaScript would be the most highly leveraged when compared to other programming languages. Why? Because today, every non-trivial web site requires you to download underscore.js or whatever its authors have chosen to use to compensate for JavaScript’s weak core. When you consider the aggregate adverse impact this has on network traffic and page load times, the numbers are frightening.No, no I am not. If you are building UI using web technologies (which is a lot of developers), then I still think that JavaScript is your best bet. Modulo the emergence of Web Assembly (which is worth paying attention to), JavaScript is still the only language that runs natively in the browser. There have been many attempts to take an existing programming language and compile it to JavaScript to avoid “having to” write JavaScript. There are cases where the results were good, but they never seemed to be great. Maybe some transpilation toolchain will ultimately succeed in unseating JavaScript as the language to write in for the web, but I suspect we’ll still have the majority of web developers writing JavaScript for quite some time. Additionally, the browser is not the only place where developers are building UI using web technologies. Two other prominent examples are Electron and React Native. Electron is attractive because it lets you write once for Windows, Mac, and Linux while React Native is attractive because it lets you write once for Android and iOS. Both are also empowering because the edit/refresh cycles using those tools is much faster than their native equivalents. From a hiring perspective, it seems like developers who know web technologies (1) are available in greater numbers than native developers, and (2) can support more platforms with smaller teams compared to native developers. Indeed, I could envision ways in which these platforms could be modified to support Python as the scripting language instead of JavaScript, which could change the calculus. However, one thing that all of the crazy tooling that exists in the JavaScript community has given way to is transpiler toolchains like Babel, which make it easier for ordinary developers (who do not have to be compiler hackers) to experiment with new JavaScript syntax. In particular, this tooling has paved the way for things like JSX, which I contend is one of the key features that makes React such an enjoyable technology for building UI. (Note that you can use React without JSX, but it is tedious.) To the best of my knowledge, the Python community does not have an equivalent, popular mechanism for experimenting with DSLs within Python. So although it might be straightforward to add Python bindings in these existing environments, I do not think that would be sufficient to get product developers to switch to Python unless changes were also made to the language that made it as easy to express UI code in Python as it is in JavaScript+JSX today.Python 3.6 has built-in support for gradual typing and async/await. Unlike JavaScript, this means that you can write Python code that uses these language features and run that file directly without any additional tooling. Further, its rich standard library means that you have to spend little time fishing around and evaluating third-party libraries to fill in missing gaps. It is very much a “get stuff done” server-side scripting language, requiring far less scaffolding than JavaScript to get a project off the ground. Although Mypy may not be as featureful or performant as Flow or TypeScript is today, the velocity of that project is certainly something that I am going to start paying attention to. By comparison, I expect that JavaScript will remain strong among product developers, but those who use Node today for server-side code or command-line tools would probably be better off using Python. If the Node community wants to resist this change, then I think they would benefit from (1) expanding the Node API to make it more comprehensive, and (2) reducing the startup time for Node. It would be even better if they could modify their runtime to recognize things like type annotations and JSX natively, though that would require changes to V8 (or Chakra, on Windows), which I expect would be difficult to maintain and/or upstream. Getting TC39 to standardize either of those language features (which would force Google/Microsoft’s hand to add native support in their JS runtimes) also seems like a tough sell. Overall, I am excited to see how things play out in both of these communities. You never know when someone will release a new technology that obsoletes your entire toolchain overnight. For all I know, we might wake up tomorrow and all decide that we should be writing OCaml. Better set your alarm clock.This post originally appeared on bolinfest.com.Docker is an open source tool that automates the deployment of the application inside software container. The easiest way to get the idea behind Docker is to compare it to, well… standard shipping containers.Back in the days, transportation companies faced the following challenges:With the introduction of containers, bricks can be put over glass, and chemicals can be stored next to food. Cargo of the various size can be put inside a standardized container that can be loaded/unloaded by the same vehicle.Let’s go back to containers in software development.When you develop an application, you need to provide your code alongside with all possible dependencies like libraries, web server, databases, etc. You may end up in a situation when the application is working on your computer but won’t even start on stage server, dev or a QA’s machine.This challenge can be addressed by isolating the app to make it independent of the system.Traditionally virtual machines were used to avoid this unexpected behavior. The main problem with VM is that “extra OS” on top of the host operating system adds gigabytes of space to the project. Most of the time your server will host several VMs that will take even more space. And by the way, at the moment most cloud-based server providers will charge you for that extra space. Another significant drawback of VM is a slow boot.Docker eliminates all the above by simply sharing OS kernel across all the containers that are running as separate processes of the host OS.Keep in mind that Docker is not the first and not the only containerization platform. However, at the moment Docker is the biggest and the most powerful player on the market.The list of benefits is the following:Docker’s native platform is Linux, as it’s based on features provided by Linux kernel. However, you can still run it on macOS and Windows. The only difference is that on macOS and Windows Docker is encapsulated into a tiny virtual machine. At the moment Docker for macOS and Windows has reached a significant level of usability and feels more like a native app.Moreover, there a lot of supplementary apps such as Kitematic or Docker Machine which help to install and operate Docker on non Linux platforms.You can check the installation instructions here. If you’re running Docker on Linux you need to run all the following commands as root or you can add your user to docker group and re-login:It’s time to run your first container:Console output:Let’s try to create an interactive shell inside Docker container:If you want to keep container running after the end of the session, you need to daemonize it:Let’s see what containers we have at the moment:Console output:The ps shows us that we have two containers:Note: there is no second container (the one with interactive shell) because we set — rm option. As a result, this container is automatically deleted right after execution.Let’s check the logs and see what daemon container is doing right now:Console output:Now let’s stop daemon container:Let’s make sure that the container has stopped.Console output:The container is stopped. We can start it again:Let’s ensure that it is running:Console output:Now let’s stop it again and remove all the containers manually:To remove all containers we can use the following command:Starting from this example you’ll need several additional files you can find on my GitHub repo. You can clone my repo or simply use the following link to download the sample files.It is time to create and run more meaningful container like Nginx.Change the directory to examples/nginx.Console output:Important: run command accepts only absolute paths. In our example we’ve used $(pwd) to set current directory absolute path.Now you can check this url in your web browser.We can try to change /example/nginx/index.html (which is mounted as a volume to/usr/share/nginx/html directory inside the container) and refresh the page.Let’s get the information about test-nginx container:This command displays system wide information about the Docker installation. This information includes the kernel version, number of containers and images, exposed ports, mounted volumes, etc.To build a Docker image you need to create a Dockerfile. It is a plain text file with instructions and arguments. Here is the description of the instructions we’re going to use in our next example:You can check Dockerfile reference for more details.Let’s create an image that will get the contents of the website with curl and store it to the text file. We need to pass website url via environment variable SITE_URL. Resulting file will be placed in a directory mounted as a volume.Dockerfile is ready, it’s time to build the actual image.Go to examples/curl and execute the following command to build an image:Console output:Now we have the new image and we can see it in the list of existing images:Console output:We can create and run container from the image. Let’s try it with default parameters:To see results saved to file run:Let’s try with facebook.com:To see results saved to file run:Docker compose — is the only right way to connect containers with each other.In this example, I am going to connect Python and Redis containers.Go to examples/compose and execute the following command:Console output:Current example will increment view counter in Redis. Open the following url in your web browser and check it.Using docker-compose is a topic for a separate article. To get started you can play with some images from Docker Hub or if you want to create your own images — follow best practices listed above. The only thing I can add in terms of using docker-compose: always give explicit names to your volumes in docker-compose.yml (if image has volumes). This simple rule will save you from issue in the future when you’ll be inspecting your volumes.In this case redis_data will be the name inside docker-compose.yml file, for the real volume name it will be prepended with project name prefix.To see volumes run:Console output:Without explicit volume name there will be UUID. And here is an example from my local machine:Docker has some restrictions and requirements depending on the architecture of your system (applications that you pack into containers). You can ignore these requirements or find some workarounds, but in this case, you won’t get all the benefits from using Docker. My strong advice is to follow these recommendations:To summarize all the above, alongside with IDE and Git, Docker has become one of the must-have developer tools.We at Django Stars have successfully implemented Docker in numerous projects. Stay tuned if you are interested in such advanced tutorials — “How to set up Django app in Docker?” and “How to use Docker and CircleCI?”.H ave you already used Docker on your project? Leave us a comment or ask questions below!At XO Group, we primarily work with Node and Ruby to build out our system of interconnected services. We get the implicit performance benefits of Node mixed with the access to a large, established repository of packages. We also have the ability to easily break out plugins and modules that can be published and reused across the company. This greatly increases developer efficiency and allows us to make scalable and reliable applications in a short amount of time. Furthermore, the large Node community makes it easy for our engineers to contribute open source software (see BunnyBus or Felicity).Although a good portion of my college days and early career was spent using strict compiled languages, like C++ and C#, I eventually shifted to using Javascript. While I love the freedom and flexibility, I recently found myself nostalgic for static and structured languages. That’s when a coworker turned my attention to Go.Coming from Javascript, there are some similarities between the two languages. Both are very fast, fairly easy to learn, have an expressive syntax, and a niche in the development community. There isn’t a perfect programming language and you should always choose a language that fits the project at hand; In this post, I will attempt to illustrate some of the key differences between the two languages at a high level and hopefully encourage anyone new to Go to give it a ̶g̶o̶ chance.Before we dive into specifics, we should understand some important distinctions between the two languages.Go, or Golang, is a free, open-source programming language created by Google in 2007. It was designed to be fast and simple. Go is compiled down into machine code, which is where its speed is derived from. Debugging is fairly easy with a compiled language because you are able to catch a large chunk of errors early on. It is also a strongly typed language which helps with data integrity and finding type errors at compile time.Javascript, on the other hand, is a loosely-typed language. Aside from the added burden of data validation and “truthy” evaluation pitfalls, using a loosely-typed language can can have its own benefits. There is no need for interfaces or generics and currying/flexible arity make functions extremely versatile. Javascript is interpreted at runtime, which can lead to issues with error handling and debugging. Node is a Javascript runtime built on Google’s V8 virtual machine making it a lightweight and fast platform for web development.Coming from Javascript, Go’s simple and intuitive syntax was very inviting. Since both languages’ syntaxes are said to have evolved from C, there is quite a bit of overlap. Go is commonly referred to as an ‘easy language to learn.’ This is due to the developer-friendly tools, pared-down syntax, and opinionated conventions.Go has a number of built-in features that make development a bit easier. The standard Go build tool lets you compile your code down into a binary file or executable with the go build command. Running tests with the built-in test suite are as simple as calling go test. Things like natively-supported concurrency are even available at the language level.According to the Go developers at Google, programming today is too complicated with too much “book keeping, repetition, and clerical work.” This is why the Go’s syntax was designed to be clean and simple in order to reduce clutter, increase efficiency, and improve readability. It also encourages developers to write explicit, easy to understand code. As a result, Go only has 25 unique keywords and one type of loop (for-loop) as opposed to ~84 keywords (reserved words, objects, properties, and methods) in Javascript.In order to illustrate some syntactical differences and similarities, let’s look at a couple of examples:Although Go and Node have their differences when it comes to which programming paradigms they enable to be easier, they both have unique and supportive followings. One area where Node outshines Go is in the sheer size of their package library and community. Node package manager (NPM), the largest package registry in the world, has over 410,000 packages growing at an alarming rate of 555 new packages per day. That number may seem staggering (and it is), however, something to keep in mind is that many of these packages are redundant and/or non-production quality. In contrast, Go has about 130,000 packages.Although Node and Go are around the same age, Javascript is more widely used — boasting a large development and open-source community. This is of course because Node was developed for the general public with a robust package manager from the start while Go was specifically built for Google. The Spectrum ratings below show the top web development languages based on current trends.While Javascript’s popularity seems to have stayed relatively static over recent years, Go has been trending up.What if your primary concern is speed? In this day and age, it seems performance optimizations are more important than ever. People don’t like to wait for information. In fact, 40% of users will abandon your site if it takes longer than 3 seconds to load.Node is often touted as a highly performant because of it’s non-blocking asynchronous I/O. Also, as I mentioned before, Node is run on Google’s V8 engine which was optimized for dynamic languages. Go on the other hand was designed with speed in mind. The developers at Google achieved this by building “an expressive but lightweight type system; concurrency and garbage collection; rigid dependency specification; and so on.”To compare the performance of Node and Go, I ran a couple of tests. These focus on the rudimentary, low-level abilities of the languages. If I had been testing something like HTTP requests or time-intensive processes, I would have used Go’s language-level concurrency tools (goroutines/channels). Instead, I stuck to basic features of each language (see Concurrency in Three Flavors for a deeper look into goroutines and channels).I also included Python in the benchmarks so we feel good about the Node and Go results no matter what.Iterating through a billion items and adding them up:The clear loser here is Python clocking in at over 7 seconds. On the other hand, both Node and Go were extremely efficient, clocking in at 900 ms and 408 ms, respectively.Edit: As some of the comments suggest, Python’s performance could be improved. The results have been updated to reflect those changes. Also, the use of PyPy greatly improves the performance. When run using Python 3.6.1 and PyPy 3.5.7, the performance improves to 1.234 seconds, but still falls short of Go and Node.Iterating over 1 million numbers and writing them to a file:Once again, Python is third at 7.94 seconds. The gap between Node and Go is small in this test, with Node taking about 1.164 seconds and Go taking 1.477 seconds (although this includes the time it takes for the Go code to compile via go run — the compiled binary shaves off another ~200 ms).Iterating 10 million times over a 10-item array and sorting:As usual, Python’s performance was the poorest, completing the task at hand in about 13 seconds. Go was able to finish the task over two times faster than Node.Go is the clear winner in all three tests, but Node, for the most part, performs admirably. And Python was there, too. To be clear, performance isn’t everything when choosing a programming language. If your application doesn’t need to process high amounts data, then the differences in performance between Node and Go may be negligible. For some additional comparisons on performance, see the following:This post is not to prove that one language is better than another. Every programming language has its place in the software development community for one reason or another. My intentions were to highlight the differences between Go and Node, as well as promote exposure to a new web development language. When choosing a language for a given project, there are a lot of different factors to consider including developer familiarity, cost, and practicality. I encourage a thorough low-level analysis when deciding what language is right for you.As we have seen, there are several benefits to Go. The raw performance, simple syntax, and relatively shallow learning curve make it ideal for scalable and secure web applications. With it’s fast growth in adoption and community involvement, there is no reason Go can’t become a prominent player in modern web development. That being said, I believe that Node is moving in the right direction to remain a powerful and useful language if implemented correctly. It has a large following and active community that makes it a simple platform for getting a web application up and running in no time.If you are interested in learning more about Go, consider the following resources:John Stamatakos is a Software Engineering Manager at XO Group in Austin, Texas. He enjoys learning new programming languages, teaching at bootcamps, hanging out with his wife and dogs, supporting the local taco economy, and writing in the third person."
  },
  {
    "link": "https://medium.freecodecamp.com/i-analyzed-every-book-ever-mentioned-on-stack-overflow-here-are-the-most-popular-ones-eee0891f1786?source=---------3-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/1*pfGJY7x362IFlEt-e0-hng.jpeg",
    "author": "Roman Gaponov",
    "date": "Mar 7",
    "photo": "https://cdn-images-1.medium.com/max/800/0*Mr3xakmAy7cOXbB9.png",
    "head": "I analyzed every book ever mentioned on Stack Overflow. Here are the most popular ones.",
    "contents": "I may be one of the last people you would expect to write an essay criticizing JavaScript, but here we are. Two of my primary areas of professional interest are JavaScript and “programming in the large.” I gave a presentation back in 2013 at mloc.js where I argued that static typing is an essential feature when picking a language for a large software project. For this reason, among others, I historically limited my use of Python to small projects with no more than a handful of files. Recently, I needed to build a command-line tool for work that could speak Thrift. I have been enjoying the Nuclide/Flow/Babel/ESLint toolchain a lot recently, so my first instinct was to use JavaScript for this new project, as well. However, it quickly became clear that if I went that route, I would have to spend a lot of time up front on getting the Thrift bindings to work properly. I couldn’t convince myself that my personal preference for JavaScript would justify such an investment, so I decided to take a look at Python. I was vaguely aware that there was an effort to add support for static typing in Python, so I Googled to find out what the state of the art was. It turns out that it is a tool named Mypy, and it provides gradual typing, much like Flow does for JavaScript or Hack does for PHP. Fortunately, Mypy is more like Hack+HHVM than it is like Flow in that a Python 3 runtime accepts the type annotations natively whereas Flow type annotations must be stripped by a separate tool before passing the code to a JavaScript runtime. (To use Mypy in Python 2, you have to put your type annotations in comments, operating in the style of the Google Closure toolchain.) Although Mypy does not appear to be as mature as Flow (support for incremental type checking is still in the works, for example), simply being able to succinctly document type information was enough to renew my interest in Python. In researching how to use Thrift from Python, a Google search turned up some sample Python code that spoke to Thrift using asynchronous abstractions. After gradual typing, async/await is the other feature in JavaScript that I cannot live without, so this code sample caught my attention! As we recently added support for building projects in Python 3.6 at work, it was trivial for me to get up and running with the latest and greatest features in Python. (Incidentally, I also learned that you really want Python 3.6, not 3.5, as 3.6 has some important improvements to Mypy, fixes to the <a href=\"https://bugs.python.org/issue28613\" data-href=\"https://bugs.python.org/issue28613\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">asyncio</a> API, literal string interpolation like you have in ES6, and more!) Coming from the era of “modern” JavaScript, one thing that was particularly refreshing was rediscovering how Python is an edit/refresh language out of the box whereas JavaScript used to be that way, but is no more. Let me explain what I mean by that:Indeed, the JavaScript ecosystem offers all sorts of tools to speed up this process using daemons and caching, but you or someone on your team has to invest quite a bit of time researching, assembling, and maintaining a JavaScript toolchain for your project before anyone can write a line of “modern” JavaScript. Although you may ultimately achieve a nice edit/refresh workflow, you certainly will not have one out of the box as you would in Python.Another refreshing difference between JavaScript and Python is the “batteries included” nature of Python. If you look at the standard library that comes with JavaScript, it is fairly minimal. The Node environment does a modest job of augmenting what is provided by the standard library, but the majority of the functionality you need inevitably has to be fetched from npm. Specifically, consider the following functionality that is included in Python’s standard library, but must be fetched from npm for a Node project:As you can see, for many of these features, there are multiple third-party libraries that provide overlapping functionality. (For example, if you were looking for a JSON parser, would you choose parse-json, safe-json-parse, fast-json-parse, jsonparse, or json-parser?) To make matters worse, npm module names are doled out on a first-come, first-serve basis. Much like domain names, this means that great names often go to undeserving projects. (For example, judging from its download count, the npm module named <a href=\"https://www.npmjs.com/package/logging\" data-href=\"https://www.npmjs.com/package/logging\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">logging</a> makes it one of the least popular logging packages for JavaScript.) This makes the comparison of third-party modules all the more time-consuming since the quality of the name is not a useful signal for the quality of the library. It might be possible that Python&#39;s third-party ecosystem is just as bad as npm&#39;s. What is impressive is that I have no idea whether that is the case because it is so rare that I have to look to a third-party Python package to get the functionality that I need. I am aware that data scientists rely heavily on third-party packages like NumPy, but unlike the Node ecosystem, there is one NumPy package that everyone uses rather than a litany of competitors named numpy-fast, numpy-plus, simple-numpy, etc.For me, one of the great ironies in all this is that, arguably, the presence of a strong standard library in JavaScript would be the most highly leveraged when compared to other programming languages. Why? Because today, every non-trivial web site requires you to download underscore.js or whatever its authors have chosen to use to compensate for JavaScript’s weak core. When you consider the aggregate adverse impact this has on network traffic and page load times, the numbers are frightening.No, no I am not. If you are building UI using web technologies (which is a lot of developers), then I still think that JavaScript is your best bet. Modulo the emergence of Web Assembly (which is worth paying attention to), JavaScript is still the only language that runs natively in the browser. There have been many attempts to take an existing programming language and compile it to JavaScript to avoid “having to” write JavaScript. There are cases where the results were good, but they never seemed to be great. Maybe some transpilation toolchain will ultimately succeed in unseating JavaScript as the language to write in for the web, but I suspect we’ll still have the majority of web developers writing JavaScript for quite some time. Additionally, the browser is not the only place where developers are building UI using web technologies. Two other prominent examples are Electron and React Native. Electron is attractive because it lets you write once for Windows, Mac, and Linux while React Native is attractive because it lets you write once for Android and iOS. Both are also empowering because the edit/refresh cycles using those tools is much faster than their native equivalents. From a hiring perspective, it seems like developers who know web technologies (1) are available in greater numbers than native developers, and (2) can support more platforms with smaller teams compared to native developers. Indeed, I could envision ways in which these platforms could be modified to support Python as the scripting language instead of JavaScript, which could change the calculus. However, one thing that all of the crazy tooling that exists in the JavaScript community has given way to is transpiler toolchains like Babel, which make it easier for ordinary developers (who do not have to be compiler hackers) to experiment with new JavaScript syntax. In particular, this tooling has paved the way for things like JSX, which I contend is one of the key features that makes React such an enjoyable technology for building UI. (Note that you can use React without JSX, but it is tedious.) To the best of my knowledge, the Python community does not have an equivalent, popular mechanism for experimenting with DSLs within Python. So although it might be straightforward to add Python bindings in these existing environments, I do not think that would be sufficient to get product developers to switch to Python unless changes were also made to the language that made it as easy to express UI code in Python as it is in JavaScript+JSX today.Python 3.6 has built-in support for gradual typing and async/await. Unlike JavaScript, this means that you can write Python code that uses these language features and run that file directly without any additional tooling. Further, its rich standard library means that you have to spend little time fishing around and evaluating third-party libraries to fill in missing gaps. It is very much a “get stuff done” server-side scripting language, requiring far less scaffolding than JavaScript to get a project off the ground. Although Mypy may not be as featureful or performant as Flow or TypeScript is today, the velocity of that project is certainly something that I am going to start paying attention to. By comparison, I expect that JavaScript will remain strong among product developers, but those who use Node today for server-side code or command-line tools would probably be better off using Python. If the Node community wants to resist this change, then I think they would benefit from (1) expanding the Node API to make it more comprehensive, and (2) reducing the startup time for Node. It would be even better if they could modify their runtime to recognize things like type annotations and JSX natively, though that would require changes to V8 (or Chakra, on Windows), which I expect would be difficult to maintain and/or upstream. Getting TC39 to standardize either of those language features (which would force Google/Microsoft’s hand to add native support in their JS runtimes) also seems like a tough sell. Overall, I am excited to see how things play out in both of these communities. You never know when someone will release a new technology that obsoletes your entire toolchain overnight. For all I know, we might wake up tomorrow and all decide that we should be writing OCaml. Better set your alarm clock.This post originally appeared on bolinfest.com.Docker is an open source tool that automates the deployment of the application inside software container. The easiest way to get the idea behind Docker is to compare it to, well… standard shipping containers.Back in the days, transportation companies faced the following challenges:With the introduction of containers, bricks can be put over glass, and chemicals can be stored next to food. Cargo of the various size can be put inside a standardized container that can be loaded/unloaded by the same vehicle.Let’s go back to containers in software development.When you develop an application, you need to provide your code alongside with all possible dependencies like libraries, web server, databases, etc. You may end up in a situation when the application is working on your computer but won’t even start on stage server, dev or a QA’s machine.This challenge can be addressed by isolating the app to make it independent of the system.Traditionally virtual machines were used to avoid this unexpected behavior. The main problem with VM is that “extra OS” on top of the host operating system adds gigabytes of space to the project. Most of the time your server will host several VMs that will take even more space. And by the way, at the moment most cloud-based server providers will charge you for that extra space. Another significant drawback of VM is a slow boot.Docker eliminates all the above by simply sharing OS kernel across all the containers that are running as separate processes of the host OS.Keep in mind that Docker is not the first and not the only containerization platform. However, at the moment Docker is the biggest and the most powerful player on the market.The list of benefits is the following:Docker’s native platform is Linux, as it’s based on features provided by Linux kernel. However, you can still run it on macOS and Windows. The only difference is that on macOS and Windows Docker is encapsulated into a tiny virtual machine. At the moment Docker for macOS and Windows has reached a significant level of usability and feels more like a native app.Moreover, there a lot of supplementary apps such as Kitematic or Docker Machine which help to install and operate Docker on non Linux platforms.You can check the installation instructions here. If you’re running Docker on Linux you need to run all the following commands as root or you can add your user to docker group and re-login:It’s time to run your first container:Console output:Let’s try to create an interactive shell inside Docker container:If you want to keep container running after the end of the session, you need to daemonize it:Let’s see what containers we have at the moment:Console output:The ps shows us that we have two containers:Note: there is no second container (the one with interactive shell) because we set — rm option. As a result, this container is automatically deleted right after execution.Let’s check the logs and see what daemon container is doing right now:Console output:Now let’s stop daemon container:Let’s make sure that the container has stopped.Console output:The container is stopped. We can start it again:Let’s ensure that it is running:Console output:Now let’s stop it again and remove all the containers manually:To remove all containers we can use the following command:Starting from this example you’ll need several additional files you can find on my GitHub repo. You can clone my repo or simply use the following link to download the sample files.It is time to create and run more meaningful container like Nginx.Change the directory to examples/nginx.Console output:Important: run command accepts only absolute paths. In our example we’ve used $(pwd) to set current directory absolute path.Now you can check this url in your web browser.We can try to change /example/nginx/index.html (which is mounted as a volume to/usr/share/nginx/html directory inside the container) and refresh the page.Let’s get the information about test-nginx container:This command displays system wide information about the Docker installation. This information includes the kernel version, number of containers and images, exposed ports, mounted volumes, etc.To build a Docker image you need to create a Dockerfile. It is a plain text file with instructions and arguments. Here is the description of the instructions we’re going to use in our next example:You can check Dockerfile reference for more details.Let’s create an image that will get the contents of the website with curl and store it to the text file. We need to pass website url via environment variable SITE_URL. Resulting file will be placed in a directory mounted as a volume.Dockerfile is ready, it’s time to build the actual image.Go to examples/curl and execute the following command to build an image:Console output:Now we have the new image and we can see it in the list of existing images:Console output:We can create and run container from the image. Let’s try it with default parameters:To see results saved to file run:Let’s try with facebook.com:To see results saved to file run:Docker compose — is the only right way to connect containers with each other.In this example, I am going to connect Python and Redis containers.Go to examples/compose and execute the following command:Console output:Current example will increment view counter in Redis. Open the following url in your web browser and check it.Using docker-compose is a topic for a separate article. To get started you can play with some images from Docker Hub or if you want to create your own images — follow best practices listed above. The only thing I can add in terms of using docker-compose: always give explicit names to your volumes in docker-compose.yml (if image has volumes). This simple rule will save you from issue in the future when you’ll be inspecting your volumes.In this case redis_data will be the name inside docker-compose.yml file, for the real volume name it will be prepended with project name prefix.To see volumes run:Console output:Without explicit volume name there will be UUID. And here is an example from my local machine:Docker has some restrictions and requirements depending on the architecture of your system (applications that you pack into containers). You can ignore these requirements or find some workarounds, but in this case, you won’t get all the benefits from using Docker. My strong advice is to follow these recommendations:To summarize all the above, alongside with IDE and Git, Docker has become one of the must-have developer tools.We at Django Stars have successfully implemented Docker in numerous projects. Stay tuned if you are interested in such advanced tutorials — “How to set up Django app in Docker?” and “How to use Docker and CircleCI?”.H ave you already used Docker on your project? Leave us a comment or ask questions below!At XO Group, we primarily work with Node and Ruby to build out our system of interconnected services. We get the implicit performance benefits of Node mixed with the access to a large, established repository of packages. We also have the ability to easily break out plugins and modules that can be published and reused across the company. This greatly increases developer efficiency and allows us to make scalable and reliable applications in a short amount of time. Furthermore, the large Node community makes it easy for our engineers to contribute open source software (see BunnyBus or Felicity).Although a good portion of my college days and early career was spent using strict compiled languages, like C++ and C#, I eventually shifted to using Javascript. While I love the freedom and flexibility, I recently found myself nostalgic for static and structured languages. That’s when a coworker turned my attention to Go.Coming from Javascript, there are some similarities between the two languages. Both are very fast, fairly easy to learn, have an expressive syntax, and a niche in the development community. There isn’t a perfect programming language and you should always choose a language that fits the project at hand; In this post, I will attempt to illustrate some of the key differences between the two languages at a high level and hopefully encourage anyone new to Go to give it a ̶g̶o̶ chance.Before we dive into specifics, we should understand some important distinctions between the two languages.Go, or Golang, is a free, open-source programming language created by Google in 2007. It was designed to be fast and simple. Go is compiled down into machine code, which is where its speed is derived from. Debugging is fairly easy with a compiled language because you are able to catch a large chunk of errors early on. It is also a strongly typed language which helps with data integrity and finding type errors at compile time.Javascript, on the other hand, is a loosely-typed language. Aside from the added burden of data validation and “truthy” evaluation pitfalls, using a loosely-typed language can can have its own benefits. There is no need for interfaces or generics and currying/flexible arity make functions extremely versatile. Javascript is interpreted at runtime, which can lead to issues with error handling and debugging. Node is a Javascript runtime built on Google’s V8 virtual machine making it a lightweight and fast platform for web development.Coming from Javascript, Go’s simple and intuitive syntax was very inviting. Since both languages’ syntaxes are said to have evolved from C, there is quite a bit of overlap. Go is commonly referred to as an ‘easy language to learn.’ This is due to the developer-friendly tools, pared-down syntax, and opinionated conventions.Go has a number of built-in features that make development a bit easier. The standard Go build tool lets you compile your code down into a binary file or executable with the go build command. Running tests with the built-in test suite are as simple as calling go test. Things like natively-supported concurrency are even available at the language level.According to the Go developers at Google, programming today is too complicated with too much “book keeping, repetition, and clerical work.” This is why the Go’s syntax was designed to be clean and simple in order to reduce clutter, increase efficiency, and improve readability. It also encourages developers to write explicit, easy to understand code. As a result, Go only has 25 unique keywords and one type of loop (for-loop) as opposed to ~84 keywords (reserved words, objects, properties, and methods) in Javascript.In order to illustrate some syntactical differences and similarities, let’s look at a couple of examples:Although Go and Node have their differences when it comes to which programming paradigms they enable to be easier, they both have unique and supportive followings. One area where Node outshines Go is in the sheer size of their package library and community. Node package manager (NPM), the largest package registry in the world, has over 410,000 packages growing at an alarming rate of 555 new packages per day. That number may seem staggering (and it is), however, something to keep in mind is that many of these packages are redundant and/or non-production quality. In contrast, Go has about 130,000 packages.Although Node and Go are around the same age, Javascript is more widely used — boasting a large development and open-source community. This is of course because Node was developed for the general public with a robust package manager from the start while Go was specifically built for Google. The Spectrum ratings below show the top web development languages based on current trends.While Javascript’s popularity seems to have stayed relatively static over recent years, Go has been trending up.What if your primary concern is speed? In this day and age, it seems performance optimizations are more important than ever. People don’t like to wait for information. In fact, 40% of users will abandon your site if it takes longer than 3 seconds to load.Node is often touted as a highly performant because of it’s non-blocking asynchronous I/O. Also, as I mentioned before, Node is run on Google’s V8 engine which was optimized for dynamic languages. Go on the other hand was designed with speed in mind. The developers at Google achieved this by building “an expressive but lightweight type system; concurrency and garbage collection; rigid dependency specification; and so on.”To compare the performance of Node and Go, I ran a couple of tests. These focus on the rudimentary, low-level abilities of the languages. If I had been testing something like HTTP requests or time-intensive processes, I would have used Go’s language-level concurrency tools (goroutines/channels). Instead, I stuck to basic features of each language (see Concurrency in Three Flavors for a deeper look into goroutines and channels).I also included Python in the benchmarks so we feel good about the Node and Go results no matter what.Iterating through a billion items and adding them up:The clear loser here is Python clocking in at over 7 seconds. On the other hand, both Node and Go were extremely efficient, clocking in at 900 ms and 408 ms, respectively.Edit: As some of the comments suggest, Python’s performance could be improved. The results have been updated to reflect those changes. Also, the use of PyPy greatly improves the performance. When run using Python 3.6.1 and PyPy 3.5.7, the performance improves to 1.234 seconds, but still falls short of Go and Node.Iterating over 1 million numbers and writing them to a file:Once again, Python is third at 7.94 seconds. The gap between Node and Go is small in this test, with Node taking about 1.164 seconds and Go taking 1.477 seconds (although this includes the time it takes for the Go code to compile via go run — the compiled binary shaves off another ~200 ms).Iterating 10 million times over a 10-item array and sorting:As usual, Python’s performance was the poorest, completing the task at hand in about 13 seconds. Go was able to finish the task over two times faster than Node.Go is the clear winner in all three tests, but Node, for the most part, performs admirably. And Python was there, too. To be clear, performance isn’t everything when choosing a programming language. If your application doesn’t need to process high amounts data, then the differences in performance between Node and Go may be negligible. For some additional comparisons on performance, see the following:This post is not to prove that one language is better than another. Every programming language has its place in the software development community for one reason or another. My intentions were to highlight the differences between Go and Node, as well as promote exposure to a new web development language. When choosing a language for a given project, there are a lot of different factors to consider including developer familiarity, cost, and practicality. I encourage a thorough low-level analysis when deciding what language is right for you.As we have seen, there are several benefits to Go. The raw performance, simple syntax, and relatively shallow learning curve make it ideal for scalable and secure web applications. With it’s fast growth in adoption and community involvement, there is no reason Go can’t become a prominent player in modern web development. That being said, I believe that Node is moving in the right direction to remain a powerful and useful language if implemented correctly. It has a large following and active community that makes it a simple platform for getting a web application up and running in no time.If you are interested in learning more about Go, consider the following resources:John Stamatakos is a Software Engineering Manager at XO Group in Austin, Texas. He enjoys learning new programming languages, teaching at bootcamps, hanging out with his wife and dogs, supporting the local taco economy, and writing in the third person.Finding your next programming book is hard, and it’s risky.As a developer, your time is scarce, and reading a book takes up a lot of that time. You could be programming. You could be resting. But instead you’re allocating precious time to read and expand your skills.So which book should you read? My colleagues and I often discuss books, and I’ve noticed that our opinions on a given book vary wildly.So I decided to take a deeper look into the problem. My idea: to parse the most popular programmer resource in the world for links to a well-known book store, then count how many mentions each book has.Fortunately, Stack Exchange (the parent company of Stack Overflow) had just published their data dump. So I sat down and got to coding.Shortly afterward, I launched dev-books.com, which allows you to explore all the data I gathered and sorted. I got more than 100,000 visitors and received lots of feedback asking me to describe the whole technical process.So, as promised, I’m going to describe how I built everything right now.I grabbed the Stack Exchange database dump from archive.org.From the very beginning I realized it would not be possible to import a 48GB XML file into a freshly created database (PostgreSQL) using popular methods like myxml := pg_read_file(‘path/to/my_file.xml’), because I didn’t have 48GB of RAM on my server. So, I decided to use a SAX parser.All the values were stored between &lt;row&gt; tags, so I used a Python script to parse it:After three days of importing (almost half of the XML was imported during this time), I realized that I’d made a mistake: the ParentID attribute should have been ParentId.At this point, I didn’t want to wait for another week, and moved from an AMD E-350 (2 x 1.35GHz) to an Intel G2020 (2 x 2.90GHz). But this still didn’t speed up the process.Next decision — batch insert:StringIO lets you use a variable like file to handle the function copy_from, which uses COPY. This way, the whole import process only took one night.OK, time to create indexes. In theory, GiST indexes are slower than GIN, but take less space. So I decided to use GiST. After one more day, I had an index that took 70GB.When I tried couple of test queries, I realized that it takes way too much time to process them. The reason? Disk IO waits. SSD GOODRAM C40 120Gb helped a lot, even if it is not the fastest SSD so far.I created a brand new PostgreSQL cluster:Then I made sure to change the path in my service config (I used Manjaro OS):I Reloaded my config and started postgreSQL:This time it took couple hours to import, but I used GIN. The indexing took 20GB of space on SSD, and simple queries were taking less than a minute.With my data finally imported, I started to look for posts that mentioned books, then copied them over to a separate table using SQL:The next step was to find all the hyperlinks within those:At this point I realized that StackOverflow proxies all links like: rads.stackowerflow.com/[$isbn]/I created another table with all posts with links:Using regular expressions to extract all the ISBNs. I extracted Stack Overflow tags to another table through regexp_split_to_table.Once I had the most popular tags extracted and counted, the top of 20 most mentioned books by tags were quite similar across all tags.My next step: refining tags.The idea was to take the top-20-mentioned books from each tag and exclude books which were already processed.Since it was “one-time” job, I decided to use PostgreSQL arrays. I wrote a script to create a query like so:With the data in hand, I headed for the web.Since I’m not a web developer — and certainly not a web user interface expert — I decided to create a very simple single-page app based on a default Bootstrap theme.I created a “search by tag” option, then extracted the most popular tags to make each search clickable.I visualized the search results with a bar chart. I tried out Hightcharts and D3, but they were more for dashboards. These had some issues with responsiveness, and were quite complex to configure. So, I created my own responsive chart based on SVG. To make it responsive, it has to be redrawn on screen orientation change event:Right after I published dev-books.com I had a huge crowd checking out my web site. Apache couldn’t serve for more than 500 visitors at the same time, so I quickly set up Nginx and switched to it on the way. I was really surprised when real-time visitors shot up to 800 at same time.I hope I explained everything clearly enough for you to understand how I built this. If you have any questions, feel free to ask. You can find me on twitter and Facebook.As promised, I will publish my full report from Amazon.com and Google Analytics at the end of March. The results so far have been really surprising.Make sure you click on green heart below and follow me for more stories about technology :)Stay tuned at dev-books.com"
  },
  {
    "link": "https://medium.mybridge.co/python-top-10-articles-for-the-past-month-b6e72bb8af2a?source=---------4-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/1*lXuIZbk_9ACijbOJ5fQxmA.png",
    "author": "",
    "date": "Mar 16",
    "photo": "https://cdn-images-1.medium.com/max/2000/1*pQ2wBDU_8uUMEzJezF5mSg.png",
    "head": "Python Top 10 Articles for the Past Month",
    "contents": "I may be one of the last people you would expect to write an essay criticizing JavaScript, but here we are. Two of my primary areas of professional interest are JavaScript and “programming in the large.” I gave a presentation back in 2013 at mloc.js where I argued that static typing is an essential feature when picking a language for a large software project. For this reason, among others, I historically limited my use of Python to small projects with no more than a handful of files. Recently, I needed to build a command-line tool for work that could speak Thrift. I have been enjoying the Nuclide/Flow/Babel/ESLint toolchain a lot recently, so my first instinct was to use JavaScript for this new project, as well. However, it quickly became clear that if I went that route, I would have to spend a lot of time up front on getting the Thrift bindings to work properly. I couldn’t convince myself that my personal preference for JavaScript would justify such an investment, so I decided to take a look at Python. I was vaguely aware that there was an effort to add support for static typing in Python, so I Googled to find out what the state of the art was. It turns out that it is a tool named Mypy, and it provides gradual typing, much like Flow does for JavaScript or Hack does for PHP. Fortunately, Mypy is more like Hack+HHVM than it is like Flow in that a Python 3 runtime accepts the type annotations natively whereas Flow type annotations must be stripped by a separate tool before passing the code to a JavaScript runtime. (To use Mypy in Python 2, you have to put your type annotations in comments, operating in the style of the Google Closure toolchain.) Although Mypy does not appear to be as mature as Flow (support for incremental type checking is still in the works, for example), simply being able to succinctly document type information was enough to renew my interest in Python. In researching how to use Thrift from Python, a Google search turned up some sample Python code that spoke to Thrift using asynchronous abstractions. After gradual typing, async/await is the other feature in JavaScript that I cannot live without, so this code sample caught my attention! As we recently added support for building projects in Python 3.6 at work, it was trivial for me to get up and running with the latest and greatest features in Python. (Incidentally, I also learned that you really want Python 3.6, not 3.5, as 3.6 has some important improvements to Mypy, fixes to the <a href=\"https://bugs.python.org/issue28613\" data-href=\"https://bugs.python.org/issue28613\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">asyncio</a> API, literal string interpolation like you have in ES6, and more!) Coming from the era of “modern” JavaScript, one thing that was particularly refreshing was rediscovering how Python is an edit/refresh language out of the box whereas JavaScript used to be that way, but is no more. Let me explain what I mean by that:Indeed, the JavaScript ecosystem offers all sorts of tools to speed up this process using daemons and caching, but you or someone on your team has to invest quite a bit of time researching, assembling, and maintaining a JavaScript toolchain for your project before anyone can write a line of “modern” JavaScript. Although you may ultimately achieve a nice edit/refresh workflow, you certainly will not have one out of the box as you would in Python.Another refreshing difference between JavaScript and Python is the “batteries included” nature of Python. If you look at the standard library that comes with JavaScript, it is fairly minimal. The Node environment does a modest job of augmenting what is provided by the standard library, but the majority of the functionality you need inevitably has to be fetched from npm. Specifically, consider the following functionality that is included in Python’s standard library, but must be fetched from npm for a Node project:As you can see, for many of these features, there are multiple third-party libraries that provide overlapping functionality. (For example, if you were looking for a JSON parser, would you choose parse-json, safe-json-parse, fast-json-parse, jsonparse, or json-parser?) To make matters worse, npm module names are doled out on a first-come, first-serve basis. Much like domain names, this means that great names often go to undeserving projects. (For example, judging from its download count, the npm module named <a href=\"https://www.npmjs.com/package/logging\" data-href=\"https://www.npmjs.com/package/logging\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">logging</a> makes it one of the least popular logging packages for JavaScript.) This makes the comparison of third-party modules all the more time-consuming since the quality of the name is not a useful signal for the quality of the library. It might be possible that Python&#39;s third-party ecosystem is just as bad as npm&#39;s. What is impressive is that I have no idea whether that is the case because it is so rare that I have to look to a third-party Python package to get the functionality that I need. I am aware that data scientists rely heavily on third-party packages like NumPy, but unlike the Node ecosystem, there is one NumPy package that everyone uses rather than a litany of competitors named numpy-fast, numpy-plus, simple-numpy, etc.For me, one of the great ironies in all this is that, arguably, the presence of a strong standard library in JavaScript would be the most highly leveraged when compared to other programming languages. Why? Because today, every non-trivial web site requires you to download underscore.js or whatever its authors have chosen to use to compensate for JavaScript’s weak core. When you consider the aggregate adverse impact this has on network traffic and page load times, the numbers are frightening.No, no I am not. If you are building UI using web technologies (which is a lot of developers), then I still think that JavaScript is your best bet. Modulo the emergence of Web Assembly (which is worth paying attention to), JavaScript is still the only language that runs natively in the browser. There have been many attempts to take an existing programming language and compile it to JavaScript to avoid “having to” write JavaScript. There are cases where the results were good, but they never seemed to be great. Maybe some transpilation toolchain will ultimately succeed in unseating JavaScript as the language to write in for the web, but I suspect we’ll still have the majority of web developers writing JavaScript for quite some time. Additionally, the browser is not the only place where developers are building UI using web technologies. Two other prominent examples are Electron and React Native. Electron is attractive because it lets you write once for Windows, Mac, and Linux while React Native is attractive because it lets you write once for Android and iOS. Both are also empowering because the edit/refresh cycles using those tools is much faster than their native equivalents. From a hiring perspective, it seems like developers who know web technologies (1) are available in greater numbers than native developers, and (2) can support more platforms with smaller teams compared to native developers. Indeed, I could envision ways in which these platforms could be modified to support Python as the scripting language instead of JavaScript, which could change the calculus. However, one thing that all of the crazy tooling that exists in the JavaScript community has given way to is transpiler toolchains like Babel, which make it easier for ordinary developers (who do not have to be compiler hackers) to experiment with new JavaScript syntax. In particular, this tooling has paved the way for things like JSX, which I contend is one of the key features that makes React such an enjoyable technology for building UI. (Note that you can use React without JSX, but it is tedious.) To the best of my knowledge, the Python community does not have an equivalent, popular mechanism for experimenting with DSLs within Python. So although it might be straightforward to add Python bindings in these existing environments, I do not think that would be sufficient to get product developers to switch to Python unless changes were also made to the language that made it as easy to express UI code in Python as it is in JavaScript+JSX today.Python 3.6 has built-in support for gradual typing and async/await. Unlike JavaScript, this means that you can write Python code that uses these language features and run that file directly without any additional tooling. Further, its rich standard library means that you have to spend little time fishing around and evaluating third-party libraries to fill in missing gaps. It is very much a “get stuff done” server-side scripting language, requiring far less scaffolding than JavaScript to get a project off the ground. Although Mypy may not be as featureful or performant as Flow or TypeScript is today, the velocity of that project is certainly something that I am going to start paying attention to. By comparison, I expect that JavaScript will remain strong among product developers, but those who use Node today for server-side code or command-line tools would probably be better off using Python. If the Node community wants to resist this change, then I think they would benefit from (1) expanding the Node API to make it more comprehensive, and (2) reducing the startup time for Node. It would be even better if they could modify their runtime to recognize things like type annotations and JSX natively, though that would require changes to V8 (or Chakra, on Windows), which I expect would be difficult to maintain and/or upstream. Getting TC39 to standardize either of those language features (which would force Google/Microsoft’s hand to add native support in their JS runtimes) also seems like a tough sell. Overall, I am excited to see how things play out in both of these communities. You never know when someone will release a new technology that obsoletes your entire toolchain overnight. For all I know, we might wake up tomorrow and all decide that we should be writing OCaml. Better set your alarm clock.This post originally appeared on bolinfest.com.Docker is an open source tool that automates the deployment of the application inside software container. The easiest way to get the idea behind Docker is to compare it to, well… standard shipping containers.Back in the days, transportation companies faced the following challenges:With the introduction of containers, bricks can be put over glass, and chemicals can be stored next to food. Cargo of the various size can be put inside a standardized container that can be loaded/unloaded by the same vehicle.Let’s go back to containers in software development.When you develop an application, you need to provide your code alongside with all possible dependencies like libraries, web server, databases, etc. You may end up in a situation when the application is working on your computer but won’t even start on stage server, dev or a QA’s machine.This challenge can be addressed by isolating the app to make it independent of the system.Traditionally virtual machines were used to avoid this unexpected behavior. The main problem with VM is that “extra OS” on top of the host operating system adds gigabytes of space to the project. Most of the time your server will host several VMs that will take even more space. And by the way, at the moment most cloud-based server providers will charge you for that extra space. Another significant drawback of VM is a slow boot.Docker eliminates all the above by simply sharing OS kernel across all the containers that are running as separate processes of the host OS.Keep in mind that Docker is not the first and not the only containerization platform. However, at the moment Docker is the biggest and the most powerful player on the market.The list of benefits is the following:Docker’s native platform is Linux, as it’s based on features provided by Linux kernel. However, you can still run it on macOS and Windows. The only difference is that on macOS and Windows Docker is encapsulated into a tiny virtual machine. At the moment Docker for macOS and Windows has reached a significant level of usability and feels more like a native app.Moreover, there a lot of supplementary apps such as Kitematic or Docker Machine which help to install and operate Docker on non Linux platforms.You can check the installation instructions here. If you’re running Docker on Linux you need to run all the following commands as root or you can add your user to docker group and re-login:It’s time to run your first container:Console output:Let’s try to create an interactive shell inside Docker container:If you want to keep container running after the end of the session, you need to daemonize it:Let’s see what containers we have at the moment:Console output:The ps shows us that we have two containers:Note: there is no second container (the one with interactive shell) because we set — rm option. As a result, this container is automatically deleted right after execution.Let’s check the logs and see what daemon container is doing right now:Console output:Now let’s stop daemon container:Let’s make sure that the container has stopped.Console output:The container is stopped. We can start it again:Let’s ensure that it is running:Console output:Now let’s stop it again and remove all the containers manually:To remove all containers we can use the following command:Starting from this example you’ll need several additional files you can find on my GitHub repo. You can clone my repo or simply use the following link to download the sample files.It is time to create and run more meaningful container like Nginx.Change the directory to examples/nginx.Console output:Important: run command accepts only absolute paths. In our example we’ve used $(pwd) to set current directory absolute path.Now you can check this url in your web browser.We can try to change /example/nginx/index.html (which is mounted as a volume to/usr/share/nginx/html directory inside the container) and refresh the page.Let’s get the information about test-nginx container:This command displays system wide information about the Docker installation. This information includes the kernel version, number of containers and images, exposed ports, mounted volumes, etc.To build a Docker image you need to create a Dockerfile. It is a plain text file with instructions and arguments. Here is the description of the instructions we’re going to use in our next example:You can check Dockerfile reference for more details.Let’s create an image that will get the contents of the website with curl and store it to the text file. We need to pass website url via environment variable SITE_URL. Resulting file will be placed in a directory mounted as a volume.Dockerfile is ready, it’s time to build the actual image.Go to examples/curl and execute the following command to build an image:Console output:Now we have the new image and we can see it in the list of existing images:Console output:We can create and run container from the image. Let’s try it with default parameters:To see results saved to file run:Let’s try with facebook.com:To see results saved to file run:Docker compose — is the only right way to connect containers with each other.In this example, I am going to connect Python and Redis containers.Go to examples/compose and execute the following command:Console output:Current example will increment view counter in Redis. Open the following url in your web browser and check it.Using docker-compose is a topic for a separate article. To get started you can play with some images from Docker Hub or if you want to create your own images — follow best practices listed above. The only thing I can add in terms of using docker-compose: always give explicit names to your volumes in docker-compose.yml (if image has volumes). This simple rule will save you from issue in the future when you’ll be inspecting your volumes.In this case redis_data will be the name inside docker-compose.yml file, for the real volume name it will be prepended with project name prefix.To see volumes run:Console output:Without explicit volume name there will be UUID. And here is an example from my local machine:Docker has some restrictions and requirements depending on the architecture of your system (applications that you pack into containers). You can ignore these requirements or find some workarounds, but in this case, you won’t get all the benefits from using Docker. My strong advice is to follow these recommendations:To summarize all the above, alongside with IDE and Git, Docker has become one of the must-have developer tools.We at Django Stars have successfully implemented Docker in numerous projects. Stay tuned if you are interested in such advanced tutorials — “How to set up Django app in Docker?” and “How to use Docker and CircleCI?”.H ave you already used Docker on your project? Leave us a comment or ask questions below!At XO Group, we primarily work with Node and Ruby to build out our system of interconnected services. We get the implicit performance benefits of Node mixed with the access to a large, established repository of packages. We also have the ability to easily break out plugins and modules that can be published and reused across the company. This greatly increases developer efficiency and allows us to make scalable and reliable applications in a short amount of time. Furthermore, the large Node community makes it easy for our engineers to contribute open source software (see BunnyBus or Felicity).Although a good portion of my college days and early career was spent using strict compiled languages, like C++ and C#, I eventually shifted to using Javascript. While I love the freedom and flexibility, I recently found myself nostalgic for static and structured languages. That’s when a coworker turned my attention to Go.Coming from Javascript, there are some similarities between the two languages. Both are very fast, fairly easy to learn, have an expressive syntax, and a niche in the development community. There isn’t a perfect programming language and you should always choose a language that fits the project at hand; In this post, I will attempt to illustrate some of the key differences between the two languages at a high level and hopefully encourage anyone new to Go to give it a ̶g̶o̶ chance.Before we dive into specifics, we should understand some important distinctions between the two languages.Go, or Golang, is a free, open-source programming language created by Google in 2007. It was designed to be fast and simple. Go is compiled down into machine code, which is where its speed is derived from. Debugging is fairly easy with a compiled language because you are able to catch a large chunk of errors early on. It is also a strongly typed language which helps with data integrity and finding type errors at compile time.Javascript, on the other hand, is a loosely-typed language. Aside from the added burden of data validation and “truthy” evaluation pitfalls, using a loosely-typed language can can have its own benefits. There is no need for interfaces or generics and currying/flexible arity make functions extremely versatile. Javascript is interpreted at runtime, which can lead to issues with error handling and debugging. Node is a Javascript runtime built on Google’s V8 virtual machine making it a lightweight and fast platform for web development.Coming from Javascript, Go’s simple and intuitive syntax was very inviting. Since both languages’ syntaxes are said to have evolved from C, there is quite a bit of overlap. Go is commonly referred to as an ‘easy language to learn.’ This is due to the developer-friendly tools, pared-down syntax, and opinionated conventions.Go has a number of built-in features that make development a bit easier. The standard Go build tool lets you compile your code down into a binary file or executable with the go build command. Running tests with the built-in test suite are as simple as calling go test. Things like natively-supported concurrency are even available at the language level.According to the Go developers at Google, programming today is too complicated with too much “book keeping, repetition, and clerical work.” This is why the Go’s syntax was designed to be clean and simple in order to reduce clutter, increase efficiency, and improve readability. It also encourages developers to write explicit, easy to understand code. As a result, Go only has 25 unique keywords and one type of loop (for-loop) as opposed to ~84 keywords (reserved words, objects, properties, and methods) in Javascript.In order to illustrate some syntactical differences and similarities, let’s look at a couple of examples:Although Go and Node have their differences when it comes to which programming paradigms they enable to be easier, they both have unique and supportive followings. One area where Node outshines Go is in the sheer size of their package library and community. Node package manager (NPM), the largest package registry in the world, has over 410,000 packages growing at an alarming rate of 555 new packages per day. That number may seem staggering (and it is), however, something to keep in mind is that many of these packages are redundant and/or non-production quality. In contrast, Go has about 130,000 packages.Although Node and Go are around the same age, Javascript is more widely used — boasting a large development and open-source community. This is of course because Node was developed for the general public with a robust package manager from the start while Go was specifically built for Google. The Spectrum ratings below show the top web development languages based on current trends.While Javascript’s popularity seems to have stayed relatively static over recent years, Go has been trending up.What if your primary concern is speed? In this day and age, it seems performance optimizations are more important than ever. People don’t like to wait for information. In fact, 40% of users will abandon your site if it takes longer than 3 seconds to load.Node is often touted as a highly performant because of it’s non-blocking asynchronous I/O. Also, as I mentioned before, Node is run on Google’s V8 engine which was optimized for dynamic languages. Go on the other hand was designed with speed in mind. The developers at Google achieved this by building “an expressive but lightweight type system; concurrency and garbage collection; rigid dependency specification; and so on.”To compare the performance of Node and Go, I ran a couple of tests. These focus on the rudimentary, low-level abilities of the languages. If I had been testing something like HTTP requests or time-intensive processes, I would have used Go’s language-level concurrency tools (goroutines/channels). Instead, I stuck to basic features of each language (see Concurrency in Three Flavors for a deeper look into goroutines and channels).I also included Python in the benchmarks so we feel good about the Node and Go results no matter what.Iterating through a billion items and adding them up:The clear loser here is Python clocking in at over 7 seconds. On the other hand, both Node and Go were extremely efficient, clocking in at 900 ms and 408 ms, respectively.Edit: As some of the comments suggest, Python’s performance could be improved. The results have been updated to reflect those changes. Also, the use of PyPy greatly improves the performance. When run using Python 3.6.1 and PyPy 3.5.7, the performance improves to 1.234 seconds, but still falls short of Go and Node.Iterating over 1 million numbers and writing them to a file:Once again, Python is third at 7.94 seconds. The gap between Node and Go is small in this test, with Node taking about 1.164 seconds and Go taking 1.477 seconds (although this includes the time it takes for the Go code to compile via go run — the compiled binary shaves off another ~200 ms).Iterating 10 million times over a 10-item array and sorting:As usual, Python’s performance was the poorest, completing the task at hand in about 13 seconds. Go was able to finish the task over two times faster than Node.Go is the clear winner in all three tests, but Node, for the most part, performs admirably. And Python was there, too. To be clear, performance isn’t everything when choosing a programming language. If your application doesn’t need to process high amounts data, then the differences in performance between Node and Go may be negligible. For some additional comparisons on performance, see the following:This post is not to prove that one language is better than another. Every programming language has its place in the software development community for one reason or another. My intentions were to highlight the differences between Go and Node, as well as promote exposure to a new web development language. When choosing a language for a given project, there are a lot of different factors to consider including developer familiarity, cost, and practicality. I encourage a thorough low-level analysis when deciding what language is right for you.As we have seen, there are several benefits to Go. The raw performance, simple syntax, and relatively shallow learning curve make it ideal for scalable and secure web applications. With it’s fast growth in adoption and community involvement, there is no reason Go can’t become a prominent player in modern web development. That being said, I believe that Node is moving in the right direction to remain a powerful and useful language if implemented correctly. It has a large following and active community that makes it a simple platform for getting a web application up and running in no time.If you are interested in learning more about Go, consider the following resources:John Stamatakos is a Software Engineering Manager at XO Group in Austin, Texas. He enjoys learning new programming languages, teaching at bootcamps, hanging out with his wife and dogs, supporting the local taco economy, and writing in the third person.Finding your next programming book is hard, and it’s risky.As a developer, your time is scarce, and reading a book takes up a lot of that time. You could be programming. You could be resting. But instead you’re allocating precious time to read and expand your skills.So which book should you read? My colleagues and I often discuss books, and I’ve noticed that our opinions on a given book vary wildly.So I decided to take a deeper look into the problem. My idea: to parse the most popular programmer resource in the world for links to a well-known book store, then count how many mentions each book has.Fortunately, Stack Exchange (the parent company of Stack Overflow) had just published their data dump. So I sat down and got to coding.Shortly afterward, I launched dev-books.com, which allows you to explore all the data I gathered and sorted. I got more than 100,000 visitors and received lots of feedback asking me to describe the whole technical process.So, as promised, I’m going to describe how I built everything right now.I grabbed the Stack Exchange database dump from archive.org.From the very beginning I realized it would not be possible to import a 48GB XML file into a freshly created database (PostgreSQL) using popular methods like myxml := pg_read_file(‘path/to/my_file.xml’), because I didn’t have 48GB of RAM on my server. So, I decided to use a SAX parser.All the values were stored between &lt;row&gt; tags, so I used a Python script to parse it:After three days of importing (almost half of the XML was imported during this time), I realized that I’d made a mistake: the ParentID attribute should have been ParentId.At this point, I didn’t want to wait for another week, and moved from an AMD E-350 (2 x 1.35GHz) to an Intel G2020 (2 x 2.90GHz). But this still didn’t speed up the process.Next decision — batch insert:StringIO lets you use a variable like file to handle the function copy_from, which uses COPY. This way, the whole import process only took one night.OK, time to create indexes. In theory, GiST indexes are slower than GIN, but take less space. So I decided to use GiST. After one more day, I had an index that took 70GB.When I tried couple of test queries, I realized that it takes way too much time to process them. The reason? Disk IO waits. SSD GOODRAM C40 120Gb helped a lot, even if it is not the fastest SSD so far.I created a brand new PostgreSQL cluster:Then I made sure to change the path in my service config (I used Manjaro OS):I Reloaded my config and started postgreSQL:This time it took couple hours to import, but I used GIN. The indexing took 20GB of space on SSD, and simple queries were taking less than a minute.With my data finally imported, I started to look for posts that mentioned books, then copied them over to a separate table using SQL:The next step was to find all the hyperlinks within those:At this point I realized that StackOverflow proxies all links like: rads.stackowerflow.com/[$isbn]/I created another table with all posts with links:Using regular expressions to extract all the ISBNs. I extracted Stack Overflow tags to another table through regexp_split_to_table.Once I had the most popular tags extracted and counted, the top of 20 most mentioned books by tags were quite similar across all tags.My next step: refining tags.The idea was to take the top-20-mentioned books from each tag and exclude books which were already processed.Since it was “one-time” job, I decided to use PostgreSQL arrays. I wrote a script to create a query like so:With the data in hand, I headed for the web.Since I’m not a web developer — and certainly not a web user interface expert — I decided to create a very simple single-page app based on a default Bootstrap theme.I created a “search by tag” option, then extracted the most popular tags to make each search clickable.I visualized the search results with a bar chart. I tried out Hightcharts and D3, but they were more for dashboards. These had some issues with responsiveness, and were quite complex to configure. So, I created my own responsive chart based on SVG. To make it responsive, it has to be redrawn on screen orientation change event:Right after I published dev-books.com I had a huge crowd checking out my web site. Apache couldn’t serve for more than 500 visitors at the same time, so I quickly set up Nginx and switched to it on the way. I was really surprised when real-time visitors shot up to 800 at same time.I hope I explained everything clearly enough for you to understand how I built this. If you have any questions, feel free to ask. You can find me on twitter and Facebook.As promised, I will publish my full report from Amazon.com and Google Analytics at the end of March. The results so far have been really surprising.Make sure you click on green heart below and follow me for more stories about technology :)Stay tuned at dev-books.comBetween January and February 2017, we’ve ranked nearly 1,400 Python articles to pick the Top 10 stories (0.7% chance) that can help advance your career.Topics included in this Python list are: Stock Trading, API Design, Pandas, Scikit-Learn, Numpy, SciPy, Excel, Metaprogramming Facilities, Distributed Tracing, Garbage Collection, Django, Apache Spark. Machine Learning Top 10 is posted separately here.Mybridge AI ranks articles based on the quality of content measured by our machine and a variety of human factors including engagement and popularity. This is a competitive list and you’ll find the experience and techniques shared by Python leaders particularly useful.A million requests per second with Python: A journey to make Python with HTTP screaming fast which resulted in a new web micro-framework. Courtesy of Paweł Piotr Przeradowski and Free Code CampFrom Python to Numpy. Courtesy of Nicolas P. RougierAPI Design: Think First, Code Later. Courtesy of Jonatas Baldin and Cheesecake LabsPython Programming for Stock Trading [Part 1–12]. Courtesy of SentdexPython Excel Tutorial: The Definitive Guide. Courtesy of Karlijn WillemsUnderstanding and using Python’s metaprogramming facilities.Evolving Distributed Tracing at Uber Engineering. Courtesy Yuri Shkuro, Software Engineer at UberDismissing Python Garbage Collection at Instagram. Courtesy of Instagram EngineeringPlaying with 80 Million Amazon Product Review Ratings Using Apache Spark with Python. Courtesy of Max WoolfBuild a REST API with Django — A Test Driven Approach [Part 1]. Courtesy of jee githinji gikera and Scotch Development…………….[ Part II ]Trump2cash: A stock trading bot powered by Trump tweets, built in Python. Courtesy of Max Braun[3,529 stars on Github]Prophet: Tool for producing high quality forecasts for time series data[2,691 stars on Github].PDFTabExtract: A set of tools for extracting tables from PDF files helping to do data mining on scanned documents.[564 stars on Github]Learn Python step by step: Solve real world problems, create games, and automate your tasks[78,342 recommends, 4.5/5 stars]Become a data scientist: Comprehensive data mining and machine learning course with Python &amp; Spark[26,114 recommends, 4.5/5 stars]Pandas Cheat Sheet: Data Science and Data Wrangling in Python..Scikit-Learn Cheat Sheet: Python Machine Learning..SciPy Cheat Sheet: Linear Algebra in Python..That’s it for Python Monthly Top 10. If you like this curation, read best daily articles based on your programming skills on our iOS App."
  }
]