[
  {
    "link": "https://hackernoon.com/5-tricks-to-avoid-cross-browser-issues-81af5d2d477b?source=---------0-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/0*JShsNVJ2kXZoNRA0.jpg",
    "author": "",
    "date": "Mar 22",
    "photo": "https://cdn-images-1.medium.com/max/800/1*AHmeRFZtnHm-kc2ykDsQcw.png",
    "head": "5 Tricks to Avoid Cross Browser Issues",
    "contents": "Browser compatibility issues can be frustrating, here’s how to avoid them:1. Prefix CSS3 stylesIf you’re using any type of modern CSS snippets, like box-sizing, or background-clip, just make sure that you use the appropriate vendor prefixes.-moz- / Firefox and other browsers using Mozilla&#39;s browser engine /<br>-webkit- / Safari, Chrome and browsers using the Webkit engine /<br>-o- / Opera /<br>-ms- / Internet Explorer (but not always) /2. Use a resetYou can use normalize.css or just a simple reset found anywhere on the net. Here’s the one I use and it’s from the Genesis Framework Style Sheet.html,body,div,span,applet,object,iframe,h1,h2,<br>h3,h4,h5,h6,p,blockquote,a,abbr,acronym,address,<br>big,cite,del,dfn,em,img,ins,kbd,q,s,samp,small,<br>strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,<br>dd,ol,ul,li,fieldset,form,label,legend,table,caption,<br>tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,<br>embed,figure,figcaption,footer,header,hgroup,input,menu,<br>nav,output,ruby,section,summary,time,mark,audio,video {<br>border: 0;<br>margin: 0;<br>padding: 0;<br>vertical-align: baseline;<br>}3. Avoid padding with widthsWhen you add padding to an element with a width, it will end up much larger than what it should be. The width and the padding will be added together. So, if I have an element with the width of 100px, and I add a padding of 10px to that same element, then the awkward browser behavior will make that element 120px.To fix that, add this to everything that you do from now on: { -webkit-box-sizing: border-box; / Safari/Chrome, other WebKit /<br>-moz-box-sizing: border-box; / Firefox, other Gecko /<br>box-sizing: border-box; }4. Clear your floats, always!Make sure you clear your floats! If you don’t clear your floats, things will start acting weird. To learn more about how floats act on browsers, check out this article from Chris Coyier.To clear your floats, use this snippet of CSS:.parent-selector:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}If you wrap most of your elements, a really simple way would be to add this to your wrap class..wrap:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}Tada! Now your floats should be cleared.5. Test it out!Create your own cross-browser infrastructure or just use Endtest.If you make these things a habit, you will drastically eliminate 95% of your cross browser issues."
  },
  {
    "link": "https://medium.com/subform/better-grid-systems-in-ui-design-tools-495dc35c5791?source=---------1-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/1*k3XCfxKYpb6gPQQqwTJFIw.jpeg",
    "author": "John Howard",
    "date": "Mar 13",
    "photo": "https://cdn-images-1.medium.com/max/1000/1*ns8TDWJ8LpDM15KiANeh_Q.png",
    "head": "Better grid systems in UI design tools",
    "contents": "Browser compatibility issues can be frustrating, here’s how to avoid them:1. Prefix CSS3 stylesIf you’re using any type of modern CSS snippets, like box-sizing, or background-clip, just make sure that you use the appropriate vendor prefixes.-moz- / Firefox and other browsers using Mozilla&#39;s browser engine /<br>-webkit- / Safari, Chrome and browsers using the Webkit engine /<br>-o- / Opera /<br>-ms- / Internet Explorer (but not always) /2. Use a resetYou can use normalize.css or just a simple reset found anywhere on the net. Here’s the one I use and it’s from the Genesis Framework Style Sheet.html,body,div,span,applet,object,iframe,h1,h2,<br>h3,h4,h5,h6,p,blockquote,a,abbr,acronym,address,<br>big,cite,del,dfn,em,img,ins,kbd,q,s,samp,small,<br>strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,<br>dd,ol,ul,li,fieldset,form,label,legend,table,caption,<br>tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,<br>embed,figure,figcaption,footer,header,hgroup,input,menu,<br>nav,output,ruby,section,summary,time,mark,audio,video {<br>border: 0;<br>margin: 0;<br>padding: 0;<br>vertical-align: baseline;<br>}3. Avoid padding with widthsWhen you add padding to an element with a width, it will end up much larger than what it should be. The width and the padding will be added together. So, if I have an element with the width of 100px, and I add a padding of 10px to that same element, then the awkward browser behavior will make that element 120px.To fix that, add this to everything that you do from now on: { -webkit-box-sizing: border-box; / Safari/Chrome, other WebKit /<br>-moz-box-sizing: border-box; / Firefox, other Gecko /<br>box-sizing: border-box; }4. Clear your floats, always!Make sure you clear your floats! If you don’t clear your floats, things will start acting weird. To learn more about how floats act on browsers, check out this article from Chris Coyier.To clear your floats, use this snippet of CSS:.parent-selector:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}If you wrap most of your elements, a really simple way would be to add this to your wrap class..wrap:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}Tada! Now your floats should be cleared.5. Test it out!Create your own cross-browser infrastructure or just use Endtest.If you make these things a habit, you will drastically eliminate 95% of your cross browser issues.In the first part of this article, “Are Grid Systems Still Relevant in Digital Product Design?”, I took a look at the history of grid systems and their practical advantages. In short: grids are still useful for interface design, but the screen is much more complex than the printed page, as both the output media and content are highly variable.Software developers have tools to help manage screen layout complexity: constraint systems like iOS’ AutoLayout and Android’s ConstraintLayout, Flexbox, and even grid-specific frameworks like the upcoming CSS Grid. But layout decisions should be made by designers, not delegated to developers. They’re critical to the form and function of an interface. Designers must be able to explore the consequences of grid layout decisions visually, not just in code.75% of interface designers primarily use Photoshop, Illustrator, or Sketch. Each of these tools was created around the metaphor of the page, not the screen. Unsurprisingly, the methods for working with grids in these tools are also based on the print tradition. For digital product designers, this leads to some big pain points in everyday use.To create a grid, you typically set parameters like total width, number and width of columns, gutters, and margins:This creates a grid scaffold that is drawn as a set of guide lines on top of the artboard. Elements can then be manually snapped to these guide lines:This works fine for print. The designer knows that their publication is going to use, say, the A4 paper size. But what happens in digital, when you need to simulate a different device size? Changing the artboard dimensions means that the grid either is either too big or too small:The most common workaround to this problem is to create multiple artboards, each corresponding to a unique device category, like smartphones, tablets, and desktops. Individual grids can then be created separately for each device/artboard:This is a pretty lousy simulation of output media, though, as it only represents three potential device resolutions. (In the above example, it’s the iPhone 7, the iPad, and a 13&quot; Macbook Pro.) Are the grid decisions still sound on a Google Pixel or an iMac 5K? What about in landscape orientations or split views?Working with only few fixed grid configurations makes it easy to miss problems while you’re working. Either the developer will find them during implementation — necessitating a lot of annoying back-and-forth — or the broken layouts will end up in your final product.In the influential Grid Systems in Graphic Design, Josef Müller-Brockmann calls for grids to be specified at the start of a project, before any page layout occurs. In fact, Müller-Brockmann suggests knowing all the variables of a project before specifying the grid:These variables, of course, can have an impact on the grid system. For example: reading distance influences font size decisions and font sizes impact column widths and row heights. In print, these variables are knowable and don’t typically change. A book doesn’t suddenly become a newspaper.So it’s not surprising that print-legacy visual design tools were never designed to handle these kinds of changes. Subtracting a few units of width from the gutters—or adding in a couple more columns—means that you have to manually realign all elements to the new grid lines:For UI designers, grid changes are often necessary. It’s just not possible to account for every output and content variable before starting visual design.Furthermore, while print projects are complete when they go to press, software interfaces are never “finished.” They’re constantly being iterated and improved.As shown above, though, a simple change to the grid means manually realigning every element in a design. Multiplied by hundreds of screens, a grid change can mean hours (or days) of miserable pixel pushing.When constructing a new grid, Müller-Brockmann would make small hand sketches of potential configurations. The technical difficulty of the process was apparent even to him:Of course, this was the only means for Müller-Brockmann to cheaply experiment with possible grid layouts: he didn’t have access to the computer in 1981. It’s pretty puzzling, though, that nearly 40 years later, computer-based design tools still don’t facilitate this sort of experimentation.Much of the time, you quickly want to divide up some elements across the available space, either evenly or in proportion. This is a grid like any other, but defining a grid scaffold to do this feels premature in the early process of exploring layouts.Time to break out the calculator. Get the width of the containing space, subtract the number of gutters multiplied by their width, then divide the remainder by the number of elements. Draw an element with the result, duplicate it for each column, then distribute all of them evenly:This is straightforward enough, but manually doing calculations like this doesn’t keep up with the speed of thought. When you start asking questions like “will it be too small if I put 8 photos on this row instead of 6?”, doing the maths each time is tedious and discourages quick experimentation.All of these pain points lead to one conclusion: UI/UX designers need better ways to work with grids during visual design. Kevin Lynagh and I have been working on some solutions in our UI design tool, Subform. Let’s look at the principles (and examples) that we’ve come up with thus far. (All of these demos were recorded directly from Subform.)For grid systems to work across lots of different devices, you should to be able to specify values in flexible percentages and proportions, not just exact pixels.These values allow you to build a simple responsive grid very quickly, without doing any arithmetic. You simply set a number of columns and tell each column to stretch. The columns then evenly divide up the available space, based on the width of the artboard:Stretchable columns can be mixed with fixed columns, gutters, and margins. The gutters in the above example are set to 12px, so their width stays fixed as the artboard resizes.A stretchable column can also accept proportions. This opens up interesting possibilities for non-uniform grids, like specifying that one column should always be three times as wide as the others:Working this way makes it much easier to understand how a grid will work across different device sizes and orientations — and catch any edge cases before they get passed to the development team.In existing tools, the grid is just a collection of guide lines that overlay the artboard. Elements can be snap-aligned to these guides, but that’s all. The elements don’t know anything about their larger relationship to the grid.The thing is, a grid is the relationship between elements. Guide lines are a visual hack to assist in creating those relationships manually. It’s far better to build those relationships directly.For example, you should be able to place an element using a rule like “start in column 2, then span 4 columns.” This can be done implicitly via direct manipulation, or explicitly by using a shorthand like 2 / span 4. Now when the grid changes, the elements will automatically resize and preserve their alignments:This also opens up new possibilities for the direct manipulation of the grid itself, like resizing gutters and columns:Being able to define grids informally while working—without using a calculator—is also a much needed feature. You might want to add some elements to the artboard that automatically divide up the available space, then insert evenly sized gutters between them:Having the design tool do these calculations on the fly — instead of painstakingly doing the math by hand — makes experimentation fast and visual. Questions like “how many photos should display in a row on the smartphone?” can be easily tried out in seconds, rather than after lots of painstaking, tedious pixel pushing:Column grids cover a lot of use cases, but many layouts require both columns and rows, similar to Müller-Brockmann’s modular grid. You should be able to describe elements in both of these dimensions: “Horizontally, this element should start in column 3 and span 2 columns. Vertically, it should start on row 1 and end on row 2.”As with one-dimensional grids, resizing the grid in either direction automatically reflows the content. Subform can also calculate changes to the grid, like adding gutters, in real-time:Existing tools only allow a grid to be defined for the entire artboard, but that’s an arbitrary boundary. Grids are helpful to solve lots of design problems, not just screen-level layout.Any rectangular element should be able to contain a grid. A table, for example, might need a separate grid structure from the screen it lives on:The ability to use multiple grids and nest them also opens up a lot of creative expressiveness for the designer. (Karl Gerstner did some pretty cool work with multiple overlaid grids for Capital Magazine in 1962.)While building Subform, Kevin and I are constantly exploring how we can create a tool that maintains the immediacy and expressiveness of visual design, but adds the dynamic power of computation.In Media for Thinking the Unthinkable, Bret Victor proposes that to think about complex systems, new representations are needed — representations more powerful than the paper medium. The representations that we’re developing for grid-based layout are, we hope, a step in the right direction.And perhaps they’re even something that Joseph Müller-Brockmann might recognize: design tools for the “clearly intelligible, objective, functional, and aesthetic quality of mathematical thinking.”If you’re interested in learning more about Subform, our UI design tool, check out the website. And be sure to sign up to get early access and receive occasional updates like this article. ✌️"
  },
  {
    "link": "https://medium.freecodecamp.com/an-animated-guide-to-flexbox-d280cf6afc35?source=---------2-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/1*v1-moNUmiMN-AU-cWodIlQ.jpeg",
    "author": "",
    "date": "Jan 31",
    "photo": "https://cdn-images-1.medium.com/max/1000/1*HIADl1oL6pxXb2dMh_pXSQ.gif",
    "head": "How Flexbox works — explained with big, colorful, animated gifs",
    "contents": "Browser compatibility issues can be frustrating, here’s how to avoid them:1. Prefix CSS3 stylesIf you’re using any type of modern CSS snippets, like box-sizing, or background-clip, just make sure that you use the appropriate vendor prefixes.-moz- / Firefox and other browsers using Mozilla&#39;s browser engine /<br>-webkit- / Safari, Chrome and browsers using the Webkit engine /<br>-o- / Opera /<br>-ms- / Internet Explorer (but not always) /2. Use a resetYou can use normalize.css or just a simple reset found anywhere on the net. Here’s the one I use and it’s from the Genesis Framework Style Sheet.html,body,div,span,applet,object,iframe,h1,h2,<br>h3,h4,h5,h6,p,blockquote,a,abbr,acronym,address,<br>big,cite,del,dfn,em,img,ins,kbd,q,s,samp,small,<br>strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,<br>dd,ol,ul,li,fieldset,form,label,legend,table,caption,<br>tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,<br>embed,figure,figcaption,footer,header,hgroup,input,menu,<br>nav,output,ruby,section,summary,time,mark,audio,video {<br>border: 0;<br>margin: 0;<br>padding: 0;<br>vertical-align: baseline;<br>}3. Avoid padding with widthsWhen you add padding to an element with a width, it will end up much larger than what it should be. The width and the padding will be added together. So, if I have an element with the width of 100px, and I add a padding of 10px to that same element, then the awkward browser behavior will make that element 120px.To fix that, add this to everything that you do from now on: { -webkit-box-sizing: border-box; / Safari/Chrome, other WebKit /<br>-moz-box-sizing: border-box; / Firefox, other Gecko /<br>box-sizing: border-box; }4. Clear your floats, always!Make sure you clear your floats! If you don’t clear your floats, things will start acting weird. To learn more about how floats act on browsers, check out this article from Chris Coyier.To clear your floats, use this snippet of CSS:.parent-selector:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}If you wrap most of your elements, a really simple way would be to add this to your wrap class..wrap:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}Tada! Now your floats should be cleared.5. Test it out!Create your own cross-browser infrastructure or just use Endtest.If you make these things a habit, you will drastically eliminate 95% of your cross browser issues.In the first part of this article, “Are Grid Systems Still Relevant in Digital Product Design?”, I took a look at the history of grid systems and their practical advantages. In short: grids are still useful for interface design, but the screen is much more complex than the printed page, as both the output media and content are highly variable.Software developers have tools to help manage screen layout complexity: constraint systems like iOS’ AutoLayout and Android’s ConstraintLayout, Flexbox, and even grid-specific frameworks like the upcoming CSS Grid. But layout decisions should be made by designers, not delegated to developers. They’re critical to the form and function of an interface. Designers must be able to explore the consequences of grid layout decisions visually, not just in code.75% of interface designers primarily use Photoshop, Illustrator, or Sketch. Each of these tools was created around the metaphor of the page, not the screen. Unsurprisingly, the methods for working with grids in these tools are also based on the print tradition. For digital product designers, this leads to some big pain points in everyday use.To create a grid, you typically set parameters like total width, number and width of columns, gutters, and margins:This creates a grid scaffold that is drawn as a set of guide lines on top of the artboard. Elements can then be manually snapped to these guide lines:This works fine for print. The designer knows that their publication is going to use, say, the A4 paper size. But what happens in digital, when you need to simulate a different device size? Changing the artboard dimensions means that the grid either is either too big or too small:The most common workaround to this problem is to create multiple artboards, each corresponding to a unique device category, like smartphones, tablets, and desktops. Individual grids can then be created separately for each device/artboard:This is a pretty lousy simulation of output media, though, as it only represents three potential device resolutions. (In the above example, it’s the iPhone 7, the iPad, and a 13&quot; Macbook Pro.) Are the grid decisions still sound on a Google Pixel or an iMac 5K? What about in landscape orientations or split views?Working with only few fixed grid configurations makes it easy to miss problems while you’re working. Either the developer will find them during implementation — necessitating a lot of annoying back-and-forth — or the broken layouts will end up in your final product.In the influential Grid Systems in Graphic Design, Josef Müller-Brockmann calls for grids to be specified at the start of a project, before any page layout occurs. In fact, Müller-Brockmann suggests knowing all the variables of a project before specifying the grid:These variables, of course, can have an impact on the grid system. For example: reading distance influences font size decisions and font sizes impact column widths and row heights. In print, these variables are knowable and don’t typically change. A book doesn’t suddenly become a newspaper.So it’s not surprising that print-legacy visual design tools were never designed to handle these kinds of changes. Subtracting a few units of width from the gutters—or adding in a couple more columns—means that you have to manually realign all elements to the new grid lines:For UI designers, grid changes are often necessary. It’s just not possible to account for every output and content variable before starting visual design.Furthermore, while print projects are complete when they go to press, software interfaces are never “finished.” They’re constantly being iterated and improved.As shown above, though, a simple change to the grid means manually realigning every element in a design. Multiplied by hundreds of screens, a grid change can mean hours (or days) of miserable pixel pushing.When constructing a new grid, Müller-Brockmann would make small hand sketches of potential configurations. The technical difficulty of the process was apparent even to him:Of course, this was the only means for Müller-Brockmann to cheaply experiment with possible grid layouts: he didn’t have access to the computer in 1981. It’s pretty puzzling, though, that nearly 40 years later, computer-based design tools still don’t facilitate this sort of experimentation.Much of the time, you quickly want to divide up some elements across the available space, either evenly or in proportion. This is a grid like any other, but defining a grid scaffold to do this feels premature in the early process of exploring layouts.Time to break out the calculator. Get the width of the containing space, subtract the number of gutters multiplied by their width, then divide the remainder by the number of elements. Draw an element with the result, duplicate it for each column, then distribute all of them evenly:This is straightforward enough, but manually doing calculations like this doesn’t keep up with the speed of thought. When you start asking questions like “will it be too small if I put 8 photos on this row instead of 6?”, doing the maths each time is tedious and discourages quick experimentation.All of these pain points lead to one conclusion: UI/UX designers need better ways to work with grids during visual design. Kevin Lynagh and I have been working on some solutions in our UI design tool, Subform. Let’s look at the principles (and examples) that we’ve come up with thus far. (All of these demos were recorded directly from Subform.)For grid systems to work across lots of different devices, you should to be able to specify values in flexible percentages and proportions, not just exact pixels.These values allow you to build a simple responsive grid very quickly, without doing any arithmetic. You simply set a number of columns and tell each column to stretch. The columns then evenly divide up the available space, based on the width of the artboard:Stretchable columns can be mixed with fixed columns, gutters, and margins. The gutters in the above example are set to 12px, so their width stays fixed as the artboard resizes.A stretchable column can also accept proportions. This opens up interesting possibilities for non-uniform grids, like specifying that one column should always be three times as wide as the others:Working this way makes it much easier to understand how a grid will work across different device sizes and orientations — and catch any edge cases before they get passed to the development team.In existing tools, the grid is just a collection of guide lines that overlay the artboard. Elements can be snap-aligned to these guides, but that’s all. The elements don’t know anything about their larger relationship to the grid.The thing is, a grid is the relationship between elements. Guide lines are a visual hack to assist in creating those relationships manually. It’s far better to build those relationships directly.For example, you should be able to place an element using a rule like “start in column 2, then span 4 columns.” This can be done implicitly via direct manipulation, or explicitly by using a shorthand like 2 / span 4. Now when the grid changes, the elements will automatically resize and preserve their alignments:This also opens up new possibilities for the direct manipulation of the grid itself, like resizing gutters and columns:Being able to define grids informally while working—without using a calculator—is also a much needed feature. You might want to add some elements to the artboard that automatically divide up the available space, then insert evenly sized gutters between them:Having the design tool do these calculations on the fly — instead of painstakingly doing the math by hand — makes experimentation fast and visual. Questions like “how many photos should display in a row on the smartphone?” can be easily tried out in seconds, rather than after lots of painstaking, tedious pixel pushing:Column grids cover a lot of use cases, but many layouts require both columns and rows, similar to Müller-Brockmann’s modular grid. You should be able to describe elements in both of these dimensions: “Horizontally, this element should start in column 3 and span 2 columns. Vertically, it should start on row 1 and end on row 2.”As with one-dimensional grids, resizing the grid in either direction automatically reflows the content. Subform can also calculate changes to the grid, like adding gutters, in real-time:Existing tools only allow a grid to be defined for the entire artboard, but that’s an arbitrary boundary. Grids are helpful to solve lots of design problems, not just screen-level layout.Any rectangular element should be able to contain a grid. A table, for example, might need a separate grid structure from the screen it lives on:The ability to use multiple grids and nest them also opens up a lot of creative expressiveness for the designer. (Karl Gerstner did some pretty cool work with multiple overlaid grids for Capital Magazine in 1962.)While building Subform, Kevin and I are constantly exploring how we can create a tool that maintains the immediacy and expressiveness of visual design, but adds the dynamic power of computation.In Media for Thinking the Unthinkable, Bret Victor proposes that to think about complex systems, new representations are needed — representations more powerful than the paper medium. The representations that we’re developing for grid-based layout are, we hope, a step in the right direction.And perhaps they’re even something that Joseph Müller-Brockmann might recognize: design tools for the “clearly intelligible, objective, functional, and aesthetic quality of mathematical thinking.”If you’re interested in learning more about Subform, our UI design tool, check out the website. And be sure to sign up to get early access and receive occasional updates like this article. ✌️Flexbox promises to save us from the evils of plain CSS (like vertical alignment).Well, Flexbox does deliver on that goal. But mastering its new mental model can be challenging.So let’s take an animated look at how Flexbox works, so we can use it to build better layouts.Flexbox’s underlying principle is to make layouts flexible and intuitive.To accomplish this, it lets containers decide for themselves how to evenly distribute their children — including their size and the space between them.This all sounds good in principle. But let’s see what it looks like in practice.In this article, we’ll dive into the 5 most common Flexbox properties. We’ll explore what they do, how you can use them, and what their results will actually look like.Here’s our example webpage:You have four colored divs of various sizes, held within a grey container div. As of now, each div has defaulted to display: block. Each square thus takes up the full width of its line.In order to get started with Flexbox, you need to make your container into a flex container. This is as easy as:Not a lot has changed — your divs are displayed inline now, but that’s about it. But behind the scenes, you’ve done something powerful. You gave your squares something called a flex context.You can now start to position them within that context, with far less difficulty than traditional CSS.A Flexbox container has two axes: a main axis and a cross axis, which default to looking like this:By default, items are arranged along the main axis, from left to right. This is why your squares defaulted to a horizontal line once you applied display: flex.Flex-direction, however, let’s you rotate the main axis.There’s an important distinction to make here: flex-direction: column doesn’t align the squares on the cross axis instead of the main axis. It makes the main axis itself go from horizontal to vertical.There are a couple of other options for flex-direction, as well: row-reverse and column-reverse.Justify-content controls how you align items on the main axis.Here, you’ll dive a bit deeper into the main/cross axis distinction. First, let’s go back to flex-direction: row.You have five commands at your disposal to use justify-content:Space-around and space-between are the least intuitive. Space-between gives equal space between each square, but not between it and the container.Space-around puts an equal cushion of space on either side of the square — which means the space between the outermost squares and the container is half as much as the space between two squares (each square contributing a non-overlapping equal amount of margin, thus doubling the space).A final note: remember that justify-content works along the main-axis, and flex-direction switches the main-axis. This will be important as you move to…If you ‘get’ justify-content, align-items will be a breeze.As justify-content works along the main axis, align-items applies to the cross axis.Let’s reset our flex-direction to row, so our axes look the same as the above image.Then, let’s dive into the align-items commands.The first three are exactly the same as justify-content, so nothing too fancy here.The next two are a bit different, however.You have stretch, in which the items take up the entirety of the cross-axis, and baseline, in which the bottom of the paragraph tags are aligned.(Note that for align-items: stretch, I had to set the height of the squares to auto. Otherwise the height property would override the stretch.)For baseline, be aware that if you take away the paragraph tags, it aligns the bottom of the squares instead, like so:To demonstrate the main and cross axes better, let’s combine justify-content and align-items and see how centering works different for the two flex-direction commands:With row, the squares are set up along a horizontal main axis. With column, they fall along a vertical main axis.Even if the squares are centered both vertically and horizontally in both cases, the two are not interchangeable!Align-self allows you to manually manipulate the alignment of one particular element.It’s basically overriding align-items for one square. All the properties are the same, though it defaults to auto, in which it follows the align-items of the container.Let’s see what this looks like. You’ll apply align-self to two squares, and for the rest apply align-items: center and flex-direction: row.Even though we’ve just scratched the surface of Flexbox, these commands should be enough for you to handle most basic alignments — and to vertically align to your heart’s content.If you want to see more GIF Flexbox tutorials, or if this tutorial was helpful to you, hit the green heart below or leave a comment.Thanks for reading!"
  },
  {
    "link": "https://medium.engineering/the-unluckiest-paragraphs-751dd36d2d30?source=---------3-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/1*2ZROXpPfLOBNhdVI0cZjWg.jpeg",
    "author": "Ryan Lucas",
    "date": "Dec 4, 2015",
    "photo": "https://cdn-images-1.medium.com/max/800/1*TTPWNnPJ5hQa1sE1cNxunQ.png",
    "head": "The Unluckiest Paragraphs",
    "contents": "Browser compatibility issues can be frustrating, here’s how to avoid them:1. Prefix CSS3 stylesIf you’re using any type of modern CSS snippets, like box-sizing, or background-clip, just make sure that you use the appropriate vendor prefixes.-moz- / Firefox and other browsers using Mozilla&#39;s browser engine /<br>-webkit- / Safari, Chrome and browsers using the Webkit engine /<br>-o- / Opera /<br>-ms- / Internet Explorer (but not always) /2. Use a resetYou can use normalize.css or just a simple reset found anywhere on the net. Here’s the one I use and it’s from the Genesis Framework Style Sheet.html,body,div,span,applet,object,iframe,h1,h2,<br>h3,h4,h5,h6,p,blockquote,a,abbr,acronym,address,<br>big,cite,del,dfn,em,img,ins,kbd,q,s,samp,small,<br>strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,<br>dd,ol,ul,li,fieldset,form,label,legend,table,caption,<br>tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,<br>embed,figure,figcaption,footer,header,hgroup,input,menu,<br>nav,output,ruby,section,summary,time,mark,audio,video {<br>border: 0;<br>margin: 0;<br>padding: 0;<br>vertical-align: baseline;<br>}3. Avoid padding with widthsWhen you add padding to an element with a width, it will end up much larger than what it should be. The width and the padding will be added together. So, if I have an element with the width of 100px, and I add a padding of 10px to that same element, then the awkward browser behavior will make that element 120px.To fix that, add this to everything that you do from now on: { -webkit-box-sizing: border-box; / Safari/Chrome, other WebKit /<br>-moz-box-sizing: border-box; / Firefox, other Gecko /<br>box-sizing: border-box; }4. Clear your floats, always!Make sure you clear your floats! If you don’t clear your floats, things will start acting weird. To learn more about how floats act on browsers, check out this article from Chris Coyier.To clear your floats, use this snippet of CSS:.parent-selector:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}If you wrap most of your elements, a really simple way would be to add this to your wrap class..wrap:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}Tada! Now your floats should be cleared.5. Test it out!Create your own cross-browser infrastructure or just use Endtest.If you make these things a habit, you will drastically eliminate 95% of your cross browser issues.In the first part of this article, “Are Grid Systems Still Relevant in Digital Product Design?”, I took a look at the history of grid systems and their practical advantages. In short: grids are still useful for interface design, but the screen is much more complex than the printed page, as both the output media and content are highly variable.Software developers have tools to help manage screen layout complexity: constraint systems like iOS’ AutoLayout and Android’s ConstraintLayout, Flexbox, and even grid-specific frameworks like the upcoming CSS Grid. But layout decisions should be made by designers, not delegated to developers. They’re critical to the form and function of an interface. Designers must be able to explore the consequences of grid layout decisions visually, not just in code.75% of interface designers primarily use Photoshop, Illustrator, or Sketch. Each of these tools was created around the metaphor of the page, not the screen. Unsurprisingly, the methods for working with grids in these tools are also based on the print tradition. For digital product designers, this leads to some big pain points in everyday use.To create a grid, you typically set parameters like total width, number and width of columns, gutters, and margins:This creates a grid scaffold that is drawn as a set of guide lines on top of the artboard. Elements can then be manually snapped to these guide lines:This works fine for print. The designer knows that their publication is going to use, say, the A4 paper size. But what happens in digital, when you need to simulate a different device size? Changing the artboard dimensions means that the grid either is either too big or too small:The most common workaround to this problem is to create multiple artboards, each corresponding to a unique device category, like smartphones, tablets, and desktops. Individual grids can then be created separately for each device/artboard:This is a pretty lousy simulation of output media, though, as it only represents three potential device resolutions. (In the above example, it’s the iPhone 7, the iPad, and a 13&quot; Macbook Pro.) Are the grid decisions still sound on a Google Pixel or an iMac 5K? What about in landscape orientations or split views?Working with only few fixed grid configurations makes it easy to miss problems while you’re working. Either the developer will find them during implementation — necessitating a lot of annoying back-and-forth — or the broken layouts will end up in your final product.In the influential Grid Systems in Graphic Design, Josef Müller-Brockmann calls for grids to be specified at the start of a project, before any page layout occurs. In fact, Müller-Brockmann suggests knowing all the variables of a project before specifying the grid:These variables, of course, can have an impact on the grid system. For example: reading distance influences font size decisions and font sizes impact column widths and row heights. In print, these variables are knowable and don’t typically change. A book doesn’t suddenly become a newspaper.So it’s not surprising that print-legacy visual design tools were never designed to handle these kinds of changes. Subtracting a few units of width from the gutters—or adding in a couple more columns—means that you have to manually realign all elements to the new grid lines:For UI designers, grid changes are often necessary. It’s just not possible to account for every output and content variable before starting visual design.Furthermore, while print projects are complete when they go to press, software interfaces are never “finished.” They’re constantly being iterated and improved.As shown above, though, a simple change to the grid means manually realigning every element in a design. Multiplied by hundreds of screens, a grid change can mean hours (or days) of miserable pixel pushing.When constructing a new grid, Müller-Brockmann would make small hand sketches of potential configurations. The technical difficulty of the process was apparent even to him:Of course, this was the only means for Müller-Brockmann to cheaply experiment with possible grid layouts: he didn’t have access to the computer in 1981. It’s pretty puzzling, though, that nearly 40 years later, computer-based design tools still don’t facilitate this sort of experimentation.Much of the time, you quickly want to divide up some elements across the available space, either evenly or in proportion. This is a grid like any other, but defining a grid scaffold to do this feels premature in the early process of exploring layouts.Time to break out the calculator. Get the width of the containing space, subtract the number of gutters multiplied by their width, then divide the remainder by the number of elements. Draw an element with the result, duplicate it for each column, then distribute all of them evenly:This is straightforward enough, but manually doing calculations like this doesn’t keep up with the speed of thought. When you start asking questions like “will it be too small if I put 8 photos on this row instead of 6?”, doing the maths each time is tedious and discourages quick experimentation.All of these pain points lead to one conclusion: UI/UX designers need better ways to work with grids during visual design. Kevin Lynagh and I have been working on some solutions in our UI design tool, Subform. Let’s look at the principles (and examples) that we’ve come up with thus far. (All of these demos were recorded directly from Subform.)For grid systems to work across lots of different devices, you should to be able to specify values in flexible percentages and proportions, not just exact pixels.These values allow you to build a simple responsive grid very quickly, without doing any arithmetic. You simply set a number of columns and tell each column to stretch. The columns then evenly divide up the available space, based on the width of the artboard:Stretchable columns can be mixed with fixed columns, gutters, and margins. The gutters in the above example are set to 12px, so their width stays fixed as the artboard resizes.A stretchable column can also accept proportions. This opens up interesting possibilities for non-uniform grids, like specifying that one column should always be three times as wide as the others:Working this way makes it much easier to understand how a grid will work across different device sizes and orientations — and catch any edge cases before they get passed to the development team.In existing tools, the grid is just a collection of guide lines that overlay the artboard. Elements can be snap-aligned to these guides, but that’s all. The elements don’t know anything about their larger relationship to the grid.The thing is, a grid is the relationship between elements. Guide lines are a visual hack to assist in creating those relationships manually. It’s far better to build those relationships directly.For example, you should be able to place an element using a rule like “start in column 2, then span 4 columns.” This can be done implicitly via direct manipulation, or explicitly by using a shorthand like 2 / span 4. Now when the grid changes, the elements will automatically resize and preserve their alignments:This also opens up new possibilities for the direct manipulation of the grid itself, like resizing gutters and columns:Being able to define grids informally while working—without using a calculator—is also a much needed feature. You might want to add some elements to the artboard that automatically divide up the available space, then insert evenly sized gutters between them:Having the design tool do these calculations on the fly — instead of painstakingly doing the math by hand — makes experimentation fast and visual. Questions like “how many photos should display in a row on the smartphone?” can be easily tried out in seconds, rather than after lots of painstaking, tedious pixel pushing:Column grids cover a lot of use cases, but many layouts require both columns and rows, similar to Müller-Brockmann’s modular grid. You should be able to describe elements in both of these dimensions: “Horizontally, this element should start in column 3 and span 2 columns. Vertically, it should start on row 1 and end on row 2.”As with one-dimensional grids, resizing the grid in either direction automatically reflows the content. Subform can also calculate changes to the grid, like adding gutters, in real-time:Existing tools only allow a grid to be defined for the entire artboard, but that’s an arbitrary boundary. Grids are helpful to solve lots of design problems, not just screen-level layout.Any rectangular element should be able to contain a grid. A table, for example, might need a separate grid structure from the screen it lives on:The ability to use multiple grids and nest them also opens up a lot of creative expressiveness for the designer. (Karl Gerstner did some pretty cool work with multiple overlaid grids for Capital Magazine in 1962.)While building Subform, Kevin and I are constantly exploring how we can create a tool that maintains the immediacy and expressiveness of visual design, but adds the dynamic power of computation.In Media for Thinking the Unthinkable, Bret Victor proposes that to think about complex systems, new representations are needed — representations more powerful than the paper medium. The representations that we’re developing for grid-based layout are, we hope, a step in the right direction.And perhaps they’re even something that Joseph Müller-Brockmann might recognize: design tools for the “clearly intelligible, objective, functional, and aesthetic quality of mathematical thinking.”If you’re interested in learning more about Subform, our UI design tool, check out the website. And be sure to sign up to get early access and receive occasional updates like this article. ✌️Flexbox promises to save us from the evils of plain CSS (like vertical alignment).Well, Flexbox does deliver on that goal. But mastering its new mental model can be challenging.So let’s take an animated look at how Flexbox works, so we can use it to build better layouts.Flexbox’s underlying principle is to make layouts flexible and intuitive.To accomplish this, it lets containers decide for themselves how to evenly distribute their children — including their size and the space between them.This all sounds good in principle. But let’s see what it looks like in practice.In this article, we’ll dive into the 5 most common Flexbox properties. We’ll explore what they do, how you can use them, and what their results will actually look like.Here’s our example webpage:You have four colored divs of various sizes, held within a grey container div. As of now, each div has defaulted to display: block. Each square thus takes up the full width of its line.In order to get started with Flexbox, you need to make your container into a flex container. This is as easy as:Not a lot has changed — your divs are displayed inline now, but that’s about it. But behind the scenes, you’ve done something powerful. You gave your squares something called a flex context.You can now start to position them within that context, with far less difficulty than traditional CSS.A Flexbox container has two axes: a main axis and a cross axis, which default to looking like this:By default, items are arranged along the main axis, from left to right. This is why your squares defaulted to a horizontal line once you applied display: flex.Flex-direction, however, let’s you rotate the main axis.There’s an important distinction to make here: flex-direction: column doesn’t align the squares on the cross axis instead of the main axis. It makes the main axis itself go from horizontal to vertical.There are a couple of other options for flex-direction, as well: row-reverse and column-reverse.Justify-content controls how you align items on the main axis.Here, you’ll dive a bit deeper into the main/cross axis distinction. First, let’s go back to flex-direction: row.You have five commands at your disposal to use justify-content:Space-around and space-between are the least intuitive. Space-between gives equal space between each square, but not between it and the container.Space-around puts an equal cushion of space on either side of the square — which means the space between the outermost squares and the container is half as much as the space between two squares (each square contributing a non-overlapping equal amount of margin, thus doubling the space).A final note: remember that justify-content works along the main-axis, and flex-direction switches the main-axis. This will be important as you move to…If you ‘get’ justify-content, align-items will be a breeze.As justify-content works along the main axis, align-items applies to the cross axis.Let’s reset our flex-direction to row, so our axes look the same as the above image.Then, let’s dive into the align-items commands.The first three are exactly the same as justify-content, so nothing too fancy here.The next two are a bit different, however.You have stretch, in which the items take up the entirety of the cross-axis, and baseline, in which the bottom of the paragraph tags are aligned.(Note that for align-items: stretch, I had to set the height of the squares to auto. Otherwise the height property would override the stretch.)For baseline, be aware that if you take away the paragraph tags, it aligns the bottom of the squares instead, like so:To demonstrate the main and cross axes better, let’s combine justify-content and align-items and see how centering works different for the two flex-direction commands:With row, the squares are set up along a horizontal main axis. With column, they fall along a vertical main axis.Even if the squares are centered both vertically and horizontally in both cases, the two are not interchangeable!Align-self allows you to manually manipulate the alignment of one particular element.It’s basically overriding align-items for one square. All the properties are the same, though it defaults to auto, in which it follows the align-items of the container.Let’s see what this looks like. You’ll apply align-self to two squares, and for the rest apply align-items: center and flex-direction: row.Even though we’ve just scratched the surface of Flexbox, these commands should be enough for you to handle most basic alignments — and to vertically align to your heart’s content.If you want to see more GIF Flexbox tutorials, or if this tutorial was helpful to you, hit the green heart below or leave a comment.Thanks for reading!Yes, this is the kind of story that starts by quoting the W3C’s CSS 2.1 Specification on how to apply style rules to web pages.This text is a small-picture look at one of the grand underpinning ideas of the web. Every web page is a democracy of three parties: the author, the user, and the web browser. Each gets to contribute to the overall style of the page. And a set of laws decides how those contributions collaborate and merge, to get us to the web page you see on your screen.The precedence rules always remind me of Isaac Asimov’s “I, Robot,” where he lays out simple rules for how robots should behave, then tells stories of edge cases where the rules collide to cause problems. But Asimov’s an optimist. He believes that simple precedence rules can lead us to enlightenment, even though the road may be bumpy. It’s a comforting read for anyone that writes technical specs.This post is not about enlightenment. This post is about the problems.In early January, a user complained that they were not able to load the post “Advertising Is Not For Geniuses.” On the author’s profile page, they would click on the post link, and get an error.Our engineers couldn’t reproduce the bug. One user support guy could. He made a screencast. This became our shining example of why screencasts are useful: one inconspicuous icon in the corner gave the bug away.That stop sign is an ad blocker.On most webpages, if you click a link, the browser automatically handles loading a new page. On Medium, we speed this up a bit with JavaScript. We send a request to “https://medium.com/@ritasustelo/advertising-is-not-for-geniuses-5d1ffbc505ac?format=json,” download the article text, and render it in your browser.The ad blocker believed we were requesting advertising to show, and blocked the request.The media has been paying more attention to ad blockers in the past few months. In August, Adobe and PageFair released a report showing a steady rise in users installing ad blockers. In September, Apple launched iOS9, which allowed ad blockers on iPhones.If you think of the separation of powers between author, user, and web browser as a weird sort of government, ad blockers are The Freedom Caucus. Also known as The “Hell No” Caucus. The ad blockers are the hell-no backlash against a web plastered with too much advertising.If this is new to you, go read “Welcome to the Block Party,” which is a great summary of what’s going on.Most of the media coverage focuses on whether ad blocking is a good idea. That’s not the part I’m interested in here, because — to be obnoxiously pedantic — ad blockers do not “block ads.” They create a set of rules to try to classify ads, and implement a set of measures to block what they classified.There’s a big gap between what is classified by those rules, and what’s an ad.Some of that gap is philosophical. How do you define “advertising,” maaaaannnnnn 🌿? Some is technical. Often the classification rules are laughably simple, like checking if the address has the word “advertising” in it. Sometimes they’re more complex.One of Medium’s main theses is that “page views” is a terrible metric. It incentivizes some of the worst parts of the web, like short articles split across multiple pages to increase ad impressions. Our data science team experiments with better metrics, like how much time people spend reading.To track these metrics, we send requests to the `/_/stat` route.Many ad blockers also double as privacy protection. Someone added `/_/stat` to the EasyPrivacy block list.We used `/_/stat` for other types of statistics, including:Counterintuitively, users with this ad blocker installed saw lots of redundant onboarding popups. When they sent us emails help, we found it difficult to diagnose their problems.It gets better, though! Not all ad blockers implemented the EasyPrivacy list consistently. Some matched only `/_/stat`. Others matched anything beginning with `/_/stat`, including `/_/static/icons.svg`. Many users saw their icons vanish.We wrote a post to assure people that, no, our icons are not clandestine payloads for advertising. After some conversations with the block list maintainers, and the EFF, we simply changed the URL.By this point, we’re used to random things on Medium disappearing due to ad blockers mis-classifying. But the best one came in a few weeks ago, when someone complained that a random paragraph in a post “6 step East European weight loss system” was missing.To understand what happened, start with the Medium data model.All posts are represented as a list of paragraphs. We give each paragraph a unique name. The code to generate names is a one-liner:The oxFFFF is a hexadecimal number that translates to 65,535.This is a programmer in-joke. In “normal” math, numbers are written in base ten. You have ten digits, 0–9, and when you get to the tenth thing, you add a new position with a ‘1’ digit. Programmers sometimes use hexadecimal (base 16) numbers, which have 16 digits: 0–9, a, b, c, d, e, and f. The main advantage of this is that you can spell cool, instantly recognizable numbers like “deadbebad” or “eatbeef.”“Math.round(Math.random()  0xFFFF)” means “pick a random number between 0 and 65,535.” Our longest posts are on the order of 1,000-ish paragraphs, so this seems reasonable. “.toString(16)” means “format that number in hexadecimal.”Coincidentally, “ad” is a hexadecimal number.Can you guess what happened next?One of the ad blockers rolled out a rule that blocks anything with the ID “ad01” or “ad02.” Two out of every 65,536 paragraphs in Medium posts disappeared.The fix we added was simple, but unsettling. Way back at the top of this post, we talked about the rules of CSS precedence. They are not absolutely calibrated towards one party. They follow a set of weighting rules. There’s an old (slightly inaccurate) joke about it.We can escalate by adding an extra “.post-article” class to our selector.Some blocker could still roll out a yet more heavily-weighted rule to override our rule. We’re hoping they don’t.I feel frustrated by this dynamic.On the one hand, we have a three-party system that decides how web pages display: the author, the user, and the browser. Each party gets to add their own rules. But the author — site owners — get most of the blame when things go wrong. Power is distributed; accountability is not.On the other hand, I’m sympathetic to what the ad blockers are trying to accomplish. We don’t like the glut of ads and tracking on the web either. The tools that ad blockers have to fight back are blunt, and imperfect.Ad blockers will create collateral damage, and page authors are responsible for dealing with it. But here’s the catch: this dynamic is good for Medium. We have a user support team responding to these bug reports, and an engineering team fixing them. We can handle this damage.Random blogger Pat running their personal blog likely does not have the time or energy or expertise to handle this.A web ecosystem with ad blockers is more complicated for authors to run and maintain. A more complicated web favors big, centralized players and disfavors small, independent ones. But maybe a web of small independent players is impossible to save.Thanks to the many people who did the hard work of reporting, diagnosing, and fixing the bugs described in this post, most notably Koop, Greg, and one engineer who asked to remain anonymous (and who also suggested the title). Let us know about your favorite bugs on Medium by writing in to yourfriends@medium.com.Many of the ideas about CSS are from F A T’s talk on the history of CSS and the cascade, which you can watch online."
  },
  {
    "link": "https://cm.engineering/getting-to-know-css-grid-layout-818e43ca71a5?source=---------4-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/1*1PyqtLY7akeikTDC623GCw.jpeg",
    "author": "",
    "date": "Mar 13",
    "photo": "https://cdn-images-1.medium.com/max/800/1*MyO6enrNZEL9HSzYmdA8VA.gif",
    "head": "Getting to know CSS Grid Layout",
    "contents": "Browser compatibility issues can be frustrating, here’s how to avoid them:1. Prefix CSS3 stylesIf you’re using any type of modern CSS snippets, like box-sizing, or background-clip, just make sure that you use the appropriate vendor prefixes.-moz- / Firefox and other browsers using Mozilla&#39;s browser engine /<br>-webkit- / Safari, Chrome and browsers using the Webkit engine /<br>-o- / Opera /<br>-ms- / Internet Explorer (but not always) /2. Use a resetYou can use normalize.css or just a simple reset found anywhere on the net. Here’s the one I use and it’s from the Genesis Framework Style Sheet.html,body,div,span,applet,object,iframe,h1,h2,<br>h3,h4,h5,h6,p,blockquote,a,abbr,acronym,address,<br>big,cite,del,dfn,em,img,ins,kbd,q,s,samp,small,<br>strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,<br>dd,ol,ul,li,fieldset,form,label,legend,table,caption,<br>tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,<br>embed,figure,figcaption,footer,header,hgroup,input,menu,<br>nav,output,ruby,section,summary,time,mark,audio,video {<br>border: 0;<br>margin: 0;<br>padding: 0;<br>vertical-align: baseline;<br>}3. Avoid padding with widthsWhen you add padding to an element with a width, it will end up much larger than what it should be. The width and the padding will be added together. So, if I have an element with the width of 100px, and I add a padding of 10px to that same element, then the awkward browser behavior will make that element 120px.To fix that, add this to everything that you do from now on: { -webkit-box-sizing: border-box; / Safari/Chrome, other WebKit /<br>-moz-box-sizing: border-box; / Firefox, other Gecko /<br>box-sizing: border-box; }4. Clear your floats, always!Make sure you clear your floats! If you don’t clear your floats, things will start acting weird. To learn more about how floats act on browsers, check out this article from Chris Coyier.To clear your floats, use this snippet of CSS:.parent-selector:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}If you wrap most of your elements, a really simple way would be to add this to your wrap class..wrap:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}Tada! Now your floats should be cleared.5. Test it out!Create your own cross-browser infrastructure or just use Endtest.If you make these things a habit, you will drastically eliminate 95% of your cross browser issues.In the first part of this article, “Are Grid Systems Still Relevant in Digital Product Design?”, I took a look at the history of grid systems and their practical advantages. In short: grids are still useful for interface design, but the screen is much more complex than the printed page, as both the output media and content are highly variable.Software developers have tools to help manage screen layout complexity: constraint systems like iOS’ AutoLayout and Android’s ConstraintLayout, Flexbox, and even grid-specific frameworks like the upcoming CSS Grid. But layout decisions should be made by designers, not delegated to developers. They’re critical to the form and function of an interface. Designers must be able to explore the consequences of grid layout decisions visually, not just in code.75% of interface designers primarily use Photoshop, Illustrator, or Sketch. Each of these tools was created around the metaphor of the page, not the screen. Unsurprisingly, the methods for working with grids in these tools are also based on the print tradition. For digital product designers, this leads to some big pain points in everyday use.To create a grid, you typically set parameters like total width, number and width of columns, gutters, and margins:This creates a grid scaffold that is drawn as a set of guide lines on top of the artboard. Elements can then be manually snapped to these guide lines:This works fine for print. The designer knows that their publication is going to use, say, the A4 paper size. But what happens in digital, when you need to simulate a different device size? Changing the artboard dimensions means that the grid either is either too big or too small:The most common workaround to this problem is to create multiple artboards, each corresponding to a unique device category, like smartphones, tablets, and desktops. Individual grids can then be created separately for each device/artboard:This is a pretty lousy simulation of output media, though, as it only represents three potential device resolutions. (In the above example, it’s the iPhone 7, the iPad, and a 13&quot; Macbook Pro.) Are the grid decisions still sound on a Google Pixel or an iMac 5K? What about in landscape orientations or split views?Working with only few fixed grid configurations makes it easy to miss problems while you’re working. Either the developer will find them during implementation — necessitating a lot of annoying back-and-forth — or the broken layouts will end up in your final product.In the influential Grid Systems in Graphic Design, Josef Müller-Brockmann calls for grids to be specified at the start of a project, before any page layout occurs. In fact, Müller-Brockmann suggests knowing all the variables of a project before specifying the grid:These variables, of course, can have an impact on the grid system. For example: reading distance influences font size decisions and font sizes impact column widths and row heights. In print, these variables are knowable and don’t typically change. A book doesn’t suddenly become a newspaper.So it’s not surprising that print-legacy visual design tools were never designed to handle these kinds of changes. Subtracting a few units of width from the gutters—or adding in a couple more columns—means that you have to manually realign all elements to the new grid lines:For UI designers, grid changes are often necessary. It’s just not possible to account for every output and content variable before starting visual design.Furthermore, while print projects are complete when they go to press, software interfaces are never “finished.” They’re constantly being iterated and improved.As shown above, though, a simple change to the grid means manually realigning every element in a design. Multiplied by hundreds of screens, a grid change can mean hours (or days) of miserable pixel pushing.When constructing a new grid, Müller-Brockmann would make small hand sketches of potential configurations. The technical difficulty of the process was apparent even to him:Of course, this was the only means for Müller-Brockmann to cheaply experiment with possible grid layouts: he didn’t have access to the computer in 1981. It’s pretty puzzling, though, that nearly 40 years later, computer-based design tools still don’t facilitate this sort of experimentation.Much of the time, you quickly want to divide up some elements across the available space, either evenly or in proportion. This is a grid like any other, but defining a grid scaffold to do this feels premature in the early process of exploring layouts.Time to break out the calculator. Get the width of the containing space, subtract the number of gutters multiplied by their width, then divide the remainder by the number of elements. Draw an element with the result, duplicate it for each column, then distribute all of them evenly:This is straightforward enough, but manually doing calculations like this doesn’t keep up with the speed of thought. When you start asking questions like “will it be too small if I put 8 photos on this row instead of 6?”, doing the maths each time is tedious and discourages quick experimentation.All of these pain points lead to one conclusion: UI/UX designers need better ways to work with grids during visual design. Kevin Lynagh and I have been working on some solutions in our UI design tool, Subform. Let’s look at the principles (and examples) that we’ve come up with thus far. (All of these demos were recorded directly from Subform.)For grid systems to work across lots of different devices, you should to be able to specify values in flexible percentages and proportions, not just exact pixels.These values allow you to build a simple responsive grid very quickly, without doing any arithmetic. You simply set a number of columns and tell each column to stretch. The columns then evenly divide up the available space, based on the width of the artboard:Stretchable columns can be mixed with fixed columns, gutters, and margins. The gutters in the above example are set to 12px, so their width stays fixed as the artboard resizes.A stretchable column can also accept proportions. This opens up interesting possibilities for non-uniform grids, like specifying that one column should always be three times as wide as the others:Working this way makes it much easier to understand how a grid will work across different device sizes and orientations — and catch any edge cases before they get passed to the development team.In existing tools, the grid is just a collection of guide lines that overlay the artboard. Elements can be snap-aligned to these guides, but that’s all. The elements don’t know anything about their larger relationship to the grid.The thing is, a grid is the relationship between elements. Guide lines are a visual hack to assist in creating those relationships manually. It’s far better to build those relationships directly.For example, you should be able to place an element using a rule like “start in column 2, then span 4 columns.” This can be done implicitly via direct manipulation, or explicitly by using a shorthand like 2 / span 4. Now when the grid changes, the elements will automatically resize and preserve their alignments:This also opens up new possibilities for the direct manipulation of the grid itself, like resizing gutters and columns:Being able to define grids informally while working—without using a calculator—is also a much needed feature. You might want to add some elements to the artboard that automatically divide up the available space, then insert evenly sized gutters between them:Having the design tool do these calculations on the fly — instead of painstakingly doing the math by hand — makes experimentation fast and visual. Questions like “how many photos should display in a row on the smartphone?” can be easily tried out in seconds, rather than after lots of painstaking, tedious pixel pushing:Column grids cover a lot of use cases, but many layouts require both columns and rows, similar to Müller-Brockmann’s modular grid. You should be able to describe elements in both of these dimensions: “Horizontally, this element should start in column 3 and span 2 columns. Vertically, it should start on row 1 and end on row 2.”As with one-dimensional grids, resizing the grid in either direction automatically reflows the content. Subform can also calculate changes to the grid, like adding gutters, in real-time:Existing tools only allow a grid to be defined for the entire artboard, but that’s an arbitrary boundary. Grids are helpful to solve lots of design problems, not just screen-level layout.Any rectangular element should be able to contain a grid. A table, for example, might need a separate grid structure from the screen it lives on:The ability to use multiple grids and nest them also opens up a lot of creative expressiveness for the designer. (Karl Gerstner did some pretty cool work with multiple overlaid grids for Capital Magazine in 1962.)While building Subform, Kevin and I are constantly exploring how we can create a tool that maintains the immediacy and expressiveness of visual design, but adds the dynamic power of computation.In Media for Thinking the Unthinkable, Bret Victor proposes that to think about complex systems, new representations are needed — representations more powerful than the paper medium. The representations that we’re developing for grid-based layout are, we hope, a step in the right direction.And perhaps they’re even something that Joseph Müller-Brockmann might recognize: design tools for the “clearly intelligible, objective, functional, and aesthetic quality of mathematical thinking.”If you’re interested in learning more about Subform, our UI design tool, check out the website. And be sure to sign up to get early access and receive occasional updates like this article. ✌️Flexbox promises to save us from the evils of plain CSS (like vertical alignment).Well, Flexbox does deliver on that goal. But mastering its new mental model can be challenging.So let’s take an animated look at how Flexbox works, so we can use it to build better layouts.Flexbox’s underlying principle is to make layouts flexible and intuitive.To accomplish this, it lets containers decide for themselves how to evenly distribute their children — including their size and the space between them.This all sounds good in principle. But let’s see what it looks like in practice.In this article, we’ll dive into the 5 most common Flexbox properties. We’ll explore what they do, how you can use them, and what their results will actually look like.Here’s our example webpage:You have four colored divs of various sizes, held within a grey container div. As of now, each div has defaulted to display: block. Each square thus takes up the full width of its line.In order to get started with Flexbox, you need to make your container into a flex container. This is as easy as:Not a lot has changed — your divs are displayed inline now, but that’s about it. But behind the scenes, you’ve done something powerful. You gave your squares something called a flex context.You can now start to position them within that context, with far less difficulty than traditional CSS.A Flexbox container has two axes: a main axis and a cross axis, which default to looking like this:By default, items are arranged along the main axis, from left to right. This is why your squares defaulted to a horizontal line once you applied display: flex.Flex-direction, however, let’s you rotate the main axis.There’s an important distinction to make here: flex-direction: column doesn’t align the squares on the cross axis instead of the main axis. It makes the main axis itself go from horizontal to vertical.There are a couple of other options for flex-direction, as well: row-reverse and column-reverse.Justify-content controls how you align items on the main axis.Here, you’ll dive a bit deeper into the main/cross axis distinction. First, let’s go back to flex-direction: row.You have five commands at your disposal to use justify-content:Space-around and space-between are the least intuitive. Space-between gives equal space between each square, but not between it and the container.Space-around puts an equal cushion of space on either side of the square — which means the space between the outermost squares and the container is half as much as the space between two squares (each square contributing a non-overlapping equal amount of margin, thus doubling the space).A final note: remember that justify-content works along the main-axis, and flex-direction switches the main-axis. This will be important as you move to…If you ‘get’ justify-content, align-items will be a breeze.As justify-content works along the main axis, align-items applies to the cross axis.Let’s reset our flex-direction to row, so our axes look the same as the above image.Then, let’s dive into the align-items commands.The first three are exactly the same as justify-content, so nothing too fancy here.The next two are a bit different, however.You have stretch, in which the items take up the entirety of the cross-axis, and baseline, in which the bottom of the paragraph tags are aligned.(Note that for align-items: stretch, I had to set the height of the squares to auto. Otherwise the height property would override the stretch.)For baseline, be aware that if you take away the paragraph tags, it aligns the bottom of the squares instead, like so:To demonstrate the main and cross axes better, let’s combine justify-content and align-items and see how centering works different for the two flex-direction commands:With row, the squares are set up along a horizontal main axis. With column, they fall along a vertical main axis.Even if the squares are centered both vertically and horizontally in both cases, the two are not interchangeable!Align-self allows you to manually manipulate the alignment of one particular element.It’s basically overriding align-items for one square. All the properties are the same, though it defaults to auto, in which it follows the align-items of the container.Let’s see what this looks like. You’ll apply align-self to two squares, and for the rest apply align-items: center and flex-direction: row.Even though we’ve just scratched the surface of Flexbox, these commands should be enough for you to handle most basic alignments — and to vertically align to your heart’s content.If you want to see more GIF Flexbox tutorials, or if this tutorial was helpful to you, hit the green heart below or leave a comment.Thanks for reading!Yes, this is the kind of story that starts by quoting the W3C’s CSS 2.1 Specification on how to apply style rules to web pages.This text is a small-picture look at one of the grand underpinning ideas of the web. Every web page is a democracy of three parties: the author, the user, and the web browser. Each gets to contribute to the overall style of the page. And a set of laws decides how those contributions collaborate and merge, to get us to the web page you see on your screen.The precedence rules always remind me of Isaac Asimov’s “I, Robot,” where he lays out simple rules for how robots should behave, then tells stories of edge cases where the rules collide to cause problems. But Asimov’s an optimist. He believes that simple precedence rules can lead us to enlightenment, even though the road may be bumpy. It’s a comforting read for anyone that writes technical specs.This post is not about enlightenment. This post is about the problems.In early January, a user complained that they were not able to load the post “Advertising Is Not For Geniuses.” On the author’s profile page, they would click on the post link, and get an error.Our engineers couldn’t reproduce the bug. One user support guy could. He made a screencast. This became our shining example of why screencasts are useful: one inconspicuous icon in the corner gave the bug away.That stop sign is an ad blocker.On most webpages, if you click a link, the browser automatically handles loading a new page. On Medium, we speed this up a bit with JavaScript. We send a request to “https://medium.com/@ritasustelo/advertising-is-not-for-geniuses-5d1ffbc505ac?format=json,” download the article text, and render it in your browser.The ad blocker believed we were requesting advertising to show, and blocked the request.The media has been paying more attention to ad blockers in the past few months. In August, Adobe and PageFair released a report showing a steady rise in users installing ad blockers. In September, Apple launched iOS9, which allowed ad blockers on iPhones.If you think of the separation of powers between author, user, and web browser as a weird sort of government, ad blockers are The Freedom Caucus. Also known as The “Hell No” Caucus. The ad blockers are the hell-no backlash against a web plastered with too much advertising.If this is new to you, go read “Welcome to the Block Party,” which is a great summary of what’s going on.Most of the media coverage focuses on whether ad blocking is a good idea. That’s not the part I’m interested in here, because — to be obnoxiously pedantic — ad blockers do not “block ads.” They create a set of rules to try to classify ads, and implement a set of measures to block what they classified.There’s a big gap between what is classified by those rules, and what’s an ad.Some of that gap is philosophical. How do you define “advertising,” maaaaannnnnn 🌿? Some is technical. Often the classification rules are laughably simple, like checking if the address has the word “advertising” in it. Sometimes they’re more complex.One of Medium’s main theses is that “page views” is a terrible metric. It incentivizes some of the worst parts of the web, like short articles split across multiple pages to increase ad impressions. Our data science team experiments with better metrics, like how much time people spend reading.To track these metrics, we send requests to the `/_/stat` route.Many ad blockers also double as privacy protection. Someone added `/_/stat` to the EasyPrivacy block list.We used `/_/stat` for other types of statistics, including:Counterintuitively, users with this ad blocker installed saw lots of redundant onboarding popups. When they sent us emails help, we found it difficult to diagnose their problems.It gets better, though! Not all ad blockers implemented the EasyPrivacy list consistently. Some matched only `/_/stat`. Others matched anything beginning with `/_/stat`, including `/_/static/icons.svg`. Many users saw their icons vanish.We wrote a post to assure people that, no, our icons are not clandestine payloads for advertising. After some conversations with the block list maintainers, and the EFF, we simply changed the URL.By this point, we’re used to random things on Medium disappearing due to ad blockers mis-classifying. But the best one came in a few weeks ago, when someone complained that a random paragraph in a post “6 step East European weight loss system” was missing.To understand what happened, start with the Medium data model.All posts are represented as a list of paragraphs. We give each paragraph a unique name. The code to generate names is a one-liner:The oxFFFF is a hexadecimal number that translates to 65,535.This is a programmer in-joke. In “normal” math, numbers are written in base ten. You have ten digits, 0–9, and when you get to the tenth thing, you add a new position with a ‘1’ digit. Programmers sometimes use hexadecimal (base 16) numbers, which have 16 digits: 0–9, a, b, c, d, e, and f. The main advantage of this is that you can spell cool, instantly recognizable numbers like “deadbebad” or “eatbeef.”“Math.round(Math.random()  0xFFFF)” means “pick a random number between 0 and 65,535.” Our longest posts are on the order of 1,000-ish paragraphs, so this seems reasonable. “.toString(16)” means “format that number in hexadecimal.”Coincidentally, “ad” is a hexadecimal number.Can you guess what happened next?One of the ad blockers rolled out a rule that blocks anything with the ID “ad01” or “ad02.” Two out of every 65,536 paragraphs in Medium posts disappeared.The fix we added was simple, but unsettling. Way back at the top of this post, we talked about the rules of CSS precedence. They are not absolutely calibrated towards one party. They follow a set of weighting rules. There’s an old (slightly inaccurate) joke about it.We can escalate by adding an extra “.post-article” class to our selector.Some blocker could still roll out a yet more heavily-weighted rule to override our rule. We’re hoping they don’t.I feel frustrated by this dynamic.On the one hand, we have a three-party system that decides how web pages display: the author, the user, and the browser. Each party gets to add their own rules. But the author — site owners — get most of the blame when things go wrong. Power is distributed; accountability is not.On the other hand, I’m sympathetic to what the ad blockers are trying to accomplish. We don’t like the glut of ads and tracking on the web either. The tools that ad blockers have to fight back are blunt, and imperfect.Ad blockers will create collateral damage, and page authors are responsible for dealing with it. But here’s the catch: this dynamic is good for Medium. We have a user support team responding to these bug reports, and an engineering team fixing them. We can handle this damage.Random blogger Pat running their personal blog likely does not have the time or energy or expertise to handle this.A web ecosystem with ad blockers is more complicated for authors to run and maintain. A more complicated web favors big, centralized players and disfavors small, independent ones. But maybe a web of small independent players is impossible to save.Thanks to the many people who did the hard work of reporting, diagnosing, and fixing the bugs described in this post, most notably Koop, Greg, and one engineer who asked to remain anonymous (and who also suggested the title). Let us know about your favorite bugs on Medium by writing in to yourfriends@medium.com.Many of the ideas about CSS are from F A T’s talk on the history of CSS and the cascade, which you can watch online.CSS Grid is the most critical layout feature to come to browsers since Flexbox. It allows us to escape some of the magic numbers, hacks, and workarounds that we’ve grown accustomed to using for the last 15 years. It brings simplicity to declaring layouts that will tear a chunk out of most of the major CSS frameworks, and reduce bloat in our own hand crafted styles.If you’re not familiar with what CSS Grid is, and you’ve made it this far, it’s a layout tool that applies to a containing element which then manages how the child elements are spaced, sized, and aligned.CSS Grid gives us powerful new abilities — most notably for layout to be aware of both horizontal and vertical space at the same time, for changes to layout not to impact markup, and the ability adapt to available space without the need for media queries.At first it might seem like Grid has a lot of new syntax to learn, but you only need a fraction to get started. This article will use examples to introduce you to the various concepts important to getting started to build with CSS Grid.CSS Grid is currently being rolled out to browsers and will appear in Safari 10.1, Firefox 52, Opera 44, Chrome 57.There is an older legacy implementation available to Microsoft browsers which have a number of limitations, we’ll only briefly cover legacy implementation to explain some of the differences between newer and older implementations and how you can get around them.For most layouts, we will use the following feature query to allow older browsers to still serve layout they understand:Browsers that don’t support @supports, or don’t support grid, won’t be served the feature.To follow along properly with the examples in this article, you’ll need to use a Grid enabled browser.To demonstrate how CSS Grid defines columns, we’ll start with this layout:To create this grid we need to use grid-template-columns and grid-gap.Grid-template-columns declare how the columns of a grid will be laid out, it take a series of values separated by spaces, that declare the size of each column; the number of values specified give us the number of columns.For example, a four column grid of 250px wide columns can be expressed like this:That same layout can also be expressed with a handy repeat keyword.Grid-gap specifies the size of gutters in grid layout, it can accept one or two values, if you specify two values you are defining both the row and the column’s gutter size.In our split two-column layout example we might declare our grid like this:Unfortunately, the gap will be added to the overall width of the containing element making the calculation 100vw + 1rem, and the layout will end up with a horizontal scroll-bar.In order to fix this space overflow, we need a slightly different solution. Enter the fraction unit or FR.A fraction unit takes up a share of available space; if 900px was the available space, and one element had one fraction, and another had two fractions — the first would get 1/3 and the second would get 2/3 of that 900px.Revising our new code with fractions replacing the view-port units:To align the content in our example, we declare grid on the child elements and use the alignment properties to position them on their track; a track is just a generic name for something that is a grid column or row. Grid, like Flexbox, has a series of alignment properties — four values — start, center, end, and stretch which relate to where the children are on their appropriate track. Stretch, unlike the others, will pull the element from the start to the end of that track.In our example, to get the content to center both vertically and horizontally we can apply these properties on the container:[2 column demo]To recreate the layout with legacy grid, we have to consider many of the limitations in the implementation. Not only does grid-gap not exist in legacy grid, you must declare on each grid item where that grid item starts, otherwise it defaults to 1, meaning all of the grid children will stack on the first column.The legacy version of this layout has to handle the lack of the gap feature by adding the gap as its own grid track, and also include where each item starts:Legacy grid has a similar problem to Flexbox in IE11, setting min-height on the container won’t necessarily be honored. This problem is much easier to work around with Grid.To do this we can use the minmax function on the parent container’s row, minmax specifies a range of the largest and smallest values a row or column could be.On the child items we can declare grid and set a single column and row of 1fr.Lastly, because we can’t align from the parent like Flexbox, or modern Grid, we have to use the elements themselves to align.[Legacy 2 column demo]If you want to encourage Microsoft to update Grid in MS Edge, visit their platform status page for CSS Grid update and up-vote it out of their backlog.So far we’ve covered how to create columns, gutters, align content, and how we could support legacy grid. Let’s experiment with how to create negative space with grid.One ability Grid allows you to do is declare where a column begins on the grid item with a property called grid-column-start, this opens up possibilities for creating negative space within the grid.One way to create negative space is to set a column a number above its actual position, leaving the grid item’s original space open while it pushes that item across to a new column.In the negative space example above, the markup is a div wrapping another div.The grid is expressed like this:To get the child to start in the right hand column, we make the child start at column 2.Note: An inconsistency in Firefox 52 causes some vertical alignment problems where a row-based FR unit doesn’t stretch to the full viewport, to address this we make the children grid items, and add a single row of our desired height.[Creating negative space demo]In a four column layout, declaring grid-column-start:2; on a grid item that starts naturally in the third column will try to find the next available second column to fill the space.The grid track will skip columns until it finds the next free second column. This provides us with a method to create white space within the grid where no content grid tracks will be assigned.[Creating white space demo]What if we wanted to split the layout into four? Everything we’ve covered so far about columns also applies to rows.The problem with this example is it is an ideal scenario. Every grid item’s content is small enough to never breach the specified row size. When dealing with rows, content changes everything. Take this example of what happens when your content overflows a specified row size:We’ve created two rows of 250px, if the content inside of a row overflows the row, it’ll break out of its row and start to overlap the row’s content below it. Not really a desired outcome.What we need in this scenario is the ability to set a minimum size, but allow for it to be flexible for content, we can achieve this using the minmax keyword we used back in the legacy example.Now that we have covered the basics we need to create rows with content, we can start to build up more complex grids that are both horizontal and vertical.[Creating flexible rows with minimum sizes demo]We can start to create more complex grids by making grid items occupy multiple tracks within the grid. In a column, we can achieve this with grid-column-start and grid-column-end, or express it in shorthand like this:The drawback of this approach is it’s not very modular, and it can lead to writing a lot of code for positioning pieces of content.The span keyword is more modular because we can place it anywhere and let the grid handle it. It allows us to define from its start position, a grid item will take multiple tracks:Anywhere we put this class within a grid, it will cause that item to span three tracks from its current position.[Complex grids with span demo]We can plan out multi-track layouts by breaking apart the layout to the smallest unit in the grid layout. In this example our smallest unit is highlighted:By building around the smallest unit, we can flexibly apply span classes to create interesting layouts, and since span is additive — you can combine row and column tracks to create hierarchy in the grid.While some of the previous examples could handle changes in available space, none of them were designed specifically for these changes. Grid has two extremely powerful features for dealing with changes in available space. These features are called ‘auto-fit’ and ‘auto-fill’ and are used within a repeat function typically with a minmax function such as:These replace the number in repeat, and calculate how many columns or rows they can fit into a line. The main differences between the two is how they deal with the overflow of space on a line.Auto-fill attempts to put the largest number of repeated items into a column that it can manage without overflowing. When there isn’t enough space to add another item, the next element will be placed on the next line, and the space it couldn’t fill is left open.Auto-fit behaves in a similar fashion to auto-fill except any empty space will collapse and stretch the items on that line — giving a flexbox-like experience that collapses columns as the available space gets smaller.Layout that relies on media queries is tied to the view-port, this isn’t modular — components within a system need to be able to adapt to the space they have available. So how might this look in practice?[Grid Auto-fit demo]We’ve had nearly fifteen years of CSS floats dominating layout, we’ve learnt just about everything you could do with floats — CSS Grid is the new kid on the block and there’s still so much to experiment with and learn.At the moment the most important step is just to start building with it to get comfortable enough to create more advanced layouts. Grid is mostly uncharted territory, once we understand its capabilities better and start to combine it with other features, we’ll be able to make more interesting, flexible layouts with less overhead, and reduce the need for framework abstractions.If you’re interested in going further with CSS Grid than this article, try Rachel Andrew’s GridByExample, which explores every single feature of CSS Grid in demo with explanation."
  }
]