[
  {
    "link": "https://trackchanges.postlight.com/modern-javascript-for-ancient-web-developers-58e7cae050f9?source=---------0-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/1*FD-Jv1BgI5_HHvt8WNzLAg.png",
    "author": "",
    "date": "Mar 22",
    "photo": "https://cdn-images-1.medium.com/max/800/1*Gh5Pv0ujTuikxGZMeANfCg.png",
    "head": "Modern JavaScript for Ancient Web Developers",
    "contents": "There’s a certain kind of old-school, backend web developer who, a long time ago, mastered things like Perl or Python or PHP or Java Server Pages, maybe even Rails or Django. This person worked with giant relational databases and built APIs that serve up JSON and even (gasp!) XML.This person is a backend developer, so for a long time, JavaScript was just a fun little toy that added a bit of frontend trickery that could make things on a web page change color. If JavaScript was being really useful, it would add form validation that helped prevent the wrong information from getting into the database. Eight years ago jQuery blew this person’s mind. JavaScript itself was a language one merely tolerated, but never embraced.Then JavaScript and its modern frameworks ate backend, frontend, and everything in between, and it was time to re-become a web developer in 2017 — who writes JavaScript.Hi. I’m an ancient web developer who is learning modern JavaScript. I’ve just gotten started and I’m having a ball, but I’ve also got whiplash. There are a few things I wish I’d understood and accepted about the world of modern JavaScript before I got started.Here are some of the changes I had to make to my own mindset and expectations around learning a new ecosystem based on an old language which has taken over my craft.The modern JS world is nothing if not young and rapidly changing, so it’s easy to choose the framework or templating engine or build tool or tutorial that’s out of date or teaching a technique that’s no longer best practice (when there even is a generally-accepted notion of what “best practice” is).In those cases, it’s time to reach out to your Local Friendly Modern JavaScript Engineer, and have a little chat about the path you’re on. I’ve been lucky to get fantastic guidance from my fellow engineers here at Postlight (especially Jeremy Mack), and I thank them for putting up with my endless questions.The point is, learning modern JavaScript requires human intervention. Things haven’t settled down long enough for curriculums and guides to gel and mature, and for best practices to become authoritative for more than a few months. If you don’t have a human expert at hand, at the very least, check the date on that Medium article or tutorial or the last commit in that GitHub repository. If it’s more than a year old, it’s almost certainly not the way to go.Along these same lines: when you’re learning modern JavaScript, there’s a good chance that the solution to the problem you’re having is still getting worked out. In fact, it’s very possible it is only one code review away from getting merged into the package you’re using.When you’re working with an ancient language like PHP, you Google a question or problem, and almost 100% of the time you will find a 5-year-old Stack Overflow answer that solves it, or a full discussion in the (thorough, heavily commented, and unparalleled) documentation.Not so much with modern JavaScript. I’ve found myself trawling through comments on GitHub issues and source code only to find information that contradicts out-of-date documentation more than once. Parsing GitHub repos is part of learning and using various JavaScript packages, and for an Old Person like me, working that close to the edge can be bewildering.The other difficult thing about learning JavaScript in 2017: getting set up will feel like it takes you as long as building the app will. The sheer number of tools and plugins and packages and dependencies and editor setup and build configurations required to do it “the right way” is enough to stall you before you even get started.Do not let this stop you. I had to let go of doing it The Right Way from the get-go, and allow myself to fumble through using suboptimal or just plain amateur setups just to get comfortable with individual tools. (Let me tell you about that time I used nodemon to do my linting…) Then I’d find out better ways and incorporate what I could, when I could, on each new project.The JS world has a lot of work to do in this regard. Again, this area of modern JavaScript is a constantly moving target, but my Local Friendly Modern JS Engineers tell me that this tutorial from Jonathan Verrecchia is currently the definitive guide to building a modern JavaScript stack. For now.When you’re learning any new language, you write code and then you throw it away, and then you write some more. My modern JavaScript education has been a stepladder of tutorials, then a small tractable project during which I compiled a list of questions and problems, then a check-in with my coworkers to get answers and explanations, then more tutorials, then a slightly bigger project, more questions, a check-in — wash, rinse, repeat.Here’s an incomplete list of some of the workshops and tutorials I’ve run through in this process so far.From here I knew enough to get myself into all sorts of trouble, like experiment with Jest for testing, Botkit for more Slack bot fun, and Serverless to really hammer home the value of functional programming. If you don’t know what any of that means, that’s okay. It’s a big world, and we all take our own paths through it.Ultimately the most important thing I’ve had to remember is this: Doing is learning. Doing it badly? It’s still learning.Learning modern JavaScript these days can feel like a futile exercise in WTF. For those moments you’re wondering if you missed your calling as a barista, Google’s Addy Osmani has the right advice:Thanks to NodeSchool and Free Code Camp, two fantastic resources for beginners learning JavaScript."
  },
  {
    "link": "https://hackernoon.com/5-tricks-to-avoid-cross-browser-issues-81af5d2d477b?source=---------1-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/0*JShsNVJ2kXZoNRA0.jpg",
    "author": "Gina Trapani",
    "date": "Mar 22",
    "photo": "https://cdn-images-1.medium.com/max/800/1*AHmeRFZtnHm-kc2ykDsQcw.png",
    "head": "5 Tricks to Avoid Cross Browser Issues",
    "contents": "There’s a certain kind of old-school, backend web developer who, a long time ago, mastered things like Perl or Python or PHP or Java Server Pages, maybe even Rails or Django. This person worked with giant relational databases and built APIs that serve up JSON and even (gasp!) XML.This person is a backend developer, so for a long time, JavaScript was just a fun little toy that added a bit of frontend trickery that could make things on a web page change color. If JavaScript was being really useful, it would add form validation that helped prevent the wrong information from getting into the database. Eight years ago jQuery blew this person’s mind. JavaScript itself was a language one merely tolerated, but never embraced.Then JavaScript and its modern frameworks ate backend, frontend, and everything in between, and it was time to re-become a web developer in 2017 — who writes JavaScript.Hi. I’m an ancient web developer who is learning modern JavaScript. I’ve just gotten started and I’m having a ball, but I’ve also got whiplash. There are a few things I wish I’d understood and accepted about the world of modern JavaScript before I got started.Here are some of the changes I had to make to my own mindset and expectations around learning a new ecosystem based on an old language which has taken over my craft.The modern JS world is nothing if not young and rapidly changing, so it’s easy to choose the framework or templating engine or build tool or tutorial that’s out of date or teaching a technique that’s no longer best practice (when there even is a generally-accepted notion of what “best practice” is).In those cases, it’s time to reach out to your Local Friendly Modern JavaScript Engineer, and have a little chat about the path you’re on. I’ve been lucky to get fantastic guidance from my fellow engineers here at Postlight (especially Jeremy Mack), and I thank them for putting up with my endless questions.The point is, learning modern JavaScript requires human intervention. Things haven’t settled down long enough for curriculums and guides to gel and mature, and for best practices to become authoritative for more than a few months. If you don’t have a human expert at hand, at the very least, check the date on that Medium article or tutorial or the last commit in that GitHub repository. If it’s more than a year old, it’s almost certainly not the way to go.Along these same lines: when you’re learning modern JavaScript, there’s a good chance that the solution to the problem you’re having is still getting worked out. In fact, it’s very possible it is only one code review away from getting merged into the package you’re using.When you’re working with an ancient language like PHP, you Google a question or problem, and almost 100% of the time you will find a 5-year-old Stack Overflow answer that solves it, or a full discussion in the (thorough, heavily commented, and unparalleled) documentation.Not so much with modern JavaScript. I’ve found myself trawling through comments on GitHub issues and source code only to find information that contradicts out-of-date documentation more than once. Parsing GitHub repos is part of learning and using various JavaScript packages, and for an Old Person like me, working that close to the edge can be bewildering.The other difficult thing about learning JavaScript in 2017: getting set up will feel like it takes you as long as building the app will. The sheer number of tools and plugins and packages and dependencies and editor setup and build configurations required to do it “the right way” is enough to stall you before you even get started.Do not let this stop you. I had to let go of doing it The Right Way from the get-go, and allow myself to fumble through using suboptimal or just plain amateur setups just to get comfortable with individual tools. (Let me tell you about that time I used nodemon to do my linting…) Then I’d find out better ways and incorporate what I could, when I could, on each new project.The JS world has a lot of work to do in this regard. Again, this area of modern JavaScript is a constantly moving target, but my Local Friendly Modern JS Engineers tell me that this tutorial from Jonathan Verrecchia is currently the definitive guide to building a modern JavaScript stack. For now.When you’re learning any new language, you write code and then you throw it away, and then you write some more. My modern JavaScript education has been a stepladder of tutorials, then a small tractable project during which I compiled a list of questions and problems, then a check-in with my coworkers to get answers and explanations, then more tutorials, then a slightly bigger project, more questions, a check-in — wash, rinse, repeat.Here’s an incomplete list of some of the workshops and tutorials I’ve run through in this process so far.From here I knew enough to get myself into all sorts of trouble, like experiment with Jest for testing, Botkit for more Slack bot fun, and Serverless to really hammer home the value of functional programming. If you don’t know what any of that means, that’s okay. It’s a big world, and we all take our own paths through it.Ultimately the most important thing I’ve had to remember is this: Doing is learning. Doing it badly? It’s still learning.Learning modern JavaScript these days can feel like a futile exercise in WTF. For those moments you’re wondering if you missed your calling as a barista, Google’s Addy Osmani has the right advice:Thanks to NodeSchool and Free Code Camp, two fantastic resources for beginners learning JavaScript.Browser compatibility issues can be frustrating, here’s how to avoid them:1. Prefix CSS3 stylesIf you’re using any type of modern CSS snippets, like box-sizing, or background-clip, just make sure that you use the appropriate vendor prefixes.-moz- / Firefox and other browsers using Mozilla&#39;s browser engine /<br>-webkit- / Safari, Chrome and browsers using the Webkit engine /<br>-o- / Opera /<br>-ms- / Internet Explorer (but not always) /2. Use a resetYou can use normalize.css or just a simple reset found anywhere on the net. Here’s the one I use and it’s from the Genesis Framework Style Sheet.html,body,div,span,applet,object,iframe,h1,h2,<br>h3,h4,h5,h6,p,blockquote,a,abbr,acronym,address,<br>big,cite,del,dfn,em,img,ins,kbd,q,s,samp,small,<br>strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,<br>dd,ol,ul,li,fieldset,form,label,legend,table,caption,<br>tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,<br>embed,figure,figcaption,footer,header,hgroup,input,menu,<br>nav,output,ruby,section,summary,time,mark,audio,video {<br>border: 0;<br>margin: 0;<br>padding: 0;<br>vertical-align: baseline;<br>}3. Avoid padding with widthsWhen you add padding to an element with a width, it will end up much larger than what it should be. The width and the padding will be added together. So, if I have an element with the width of 100px, and I add a padding of 10px to that same element, then the awkward browser behavior will make that element 120px.To fix that, add this to everything that you do from now on: { -webkit-box-sizing: border-box; / Safari/Chrome, other WebKit /<br>-moz-box-sizing: border-box; / Firefox, other Gecko /<br>box-sizing: border-box; }4. Clear your floats, always!Make sure you clear your floats! If you don’t clear your floats, things will start acting weird. To learn more about how floats act on browsers, check out this article from Chris Coyier.To clear your floats, use this snippet of CSS:.parent-selector:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}If you wrap most of your elements, a really simple way would be to add this to your wrap class..wrap:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}Tada! Now your floats should be cleared.5. Test it out!Create your own cross-browser infrastructure or just use Endtest.If you make these things a habit, you will drastically eliminate 95% of your cross browser issues."
  },
  {
    "link": "https://hackernoon.com/javascript-vs-python-in-2017-d31efbb641b4?source=---------2-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/0*SOeLg85_Q-vu1u80.jpg",
    "author": "",
    "date": "Mar 20",
    "photo": "https://cdn-images-1.medium.com/max/800/1*AHmeRFZtnHm-kc2ykDsQcw.png",
    "head": "JavaScript vs. Python in 2017",
    "contents": "There’s a certain kind of old-school, backend web developer who, a long time ago, mastered things like Perl or Python or PHP or Java Server Pages, maybe even Rails or Django. This person worked with giant relational databases and built APIs that serve up JSON and even (gasp!) XML.This person is a backend developer, so for a long time, JavaScript was just a fun little toy that added a bit of frontend trickery that could make things on a web page change color. If JavaScript was being really useful, it would add form validation that helped prevent the wrong information from getting into the database. Eight years ago jQuery blew this person’s mind. JavaScript itself was a language one merely tolerated, but never embraced.Then JavaScript and its modern frameworks ate backend, frontend, and everything in between, and it was time to re-become a web developer in 2017 — who writes JavaScript.Hi. I’m an ancient web developer who is learning modern JavaScript. I’ve just gotten started and I’m having a ball, but I’ve also got whiplash. There are a few things I wish I’d understood and accepted about the world of modern JavaScript before I got started.Here are some of the changes I had to make to my own mindset and expectations around learning a new ecosystem based on an old language which has taken over my craft.The modern JS world is nothing if not young and rapidly changing, so it’s easy to choose the framework or templating engine or build tool or tutorial that’s out of date or teaching a technique that’s no longer best practice (when there even is a generally-accepted notion of what “best practice” is).In those cases, it’s time to reach out to your Local Friendly Modern JavaScript Engineer, and have a little chat about the path you’re on. I’ve been lucky to get fantastic guidance from my fellow engineers here at Postlight (especially Jeremy Mack), and I thank them for putting up with my endless questions.The point is, learning modern JavaScript requires human intervention. Things haven’t settled down long enough for curriculums and guides to gel and mature, and for best practices to become authoritative for more than a few months. If you don’t have a human expert at hand, at the very least, check the date on that Medium article or tutorial or the last commit in that GitHub repository. If it’s more than a year old, it’s almost certainly not the way to go.Along these same lines: when you’re learning modern JavaScript, there’s a good chance that the solution to the problem you’re having is still getting worked out. In fact, it’s very possible it is only one code review away from getting merged into the package you’re using.When you’re working with an ancient language like PHP, you Google a question or problem, and almost 100% of the time you will find a 5-year-old Stack Overflow answer that solves it, or a full discussion in the (thorough, heavily commented, and unparalleled) documentation.Not so much with modern JavaScript. I’ve found myself trawling through comments on GitHub issues and source code only to find information that contradicts out-of-date documentation more than once. Parsing GitHub repos is part of learning and using various JavaScript packages, and for an Old Person like me, working that close to the edge can be bewildering.The other difficult thing about learning JavaScript in 2017: getting set up will feel like it takes you as long as building the app will. The sheer number of tools and plugins and packages and dependencies and editor setup and build configurations required to do it “the right way” is enough to stall you before you even get started.Do not let this stop you. I had to let go of doing it The Right Way from the get-go, and allow myself to fumble through using suboptimal or just plain amateur setups just to get comfortable with individual tools. (Let me tell you about that time I used nodemon to do my linting…) Then I’d find out better ways and incorporate what I could, when I could, on each new project.The JS world has a lot of work to do in this regard. Again, this area of modern JavaScript is a constantly moving target, but my Local Friendly Modern JS Engineers tell me that this tutorial from Jonathan Verrecchia is currently the definitive guide to building a modern JavaScript stack. For now.When you’re learning any new language, you write code and then you throw it away, and then you write some more. My modern JavaScript education has been a stepladder of tutorials, then a small tractable project during which I compiled a list of questions and problems, then a check-in with my coworkers to get answers and explanations, then more tutorials, then a slightly bigger project, more questions, a check-in — wash, rinse, repeat.Here’s an incomplete list of some of the workshops and tutorials I’ve run through in this process so far.From here I knew enough to get myself into all sorts of trouble, like experiment with Jest for testing, Botkit for more Slack bot fun, and Serverless to really hammer home the value of functional programming. If you don’t know what any of that means, that’s okay. It’s a big world, and we all take our own paths through it.Ultimately the most important thing I’ve had to remember is this: Doing is learning. Doing it badly? It’s still learning.Learning modern JavaScript these days can feel like a futile exercise in WTF. For those moments you’re wondering if you missed your calling as a barista, Google’s Addy Osmani has the right advice:Thanks to NodeSchool and Free Code Camp, two fantastic resources for beginners learning JavaScript.Browser compatibility issues can be frustrating, here’s how to avoid them:1. Prefix CSS3 stylesIf you’re using any type of modern CSS snippets, like box-sizing, or background-clip, just make sure that you use the appropriate vendor prefixes.-moz- / Firefox and other browsers using Mozilla&#39;s browser engine /<br>-webkit- / Safari, Chrome and browsers using the Webkit engine /<br>-o- / Opera /<br>-ms- / Internet Explorer (but not always) /2. Use a resetYou can use normalize.css or just a simple reset found anywhere on the net. Here’s the one I use and it’s from the Genesis Framework Style Sheet.html,body,div,span,applet,object,iframe,h1,h2,<br>h3,h4,h5,h6,p,blockquote,a,abbr,acronym,address,<br>big,cite,del,dfn,em,img,ins,kbd,q,s,samp,small,<br>strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,<br>dd,ol,ul,li,fieldset,form,label,legend,table,caption,<br>tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,<br>embed,figure,figcaption,footer,header,hgroup,input,menu,<br>nav,output,ruby,section,summary,time,mark,audio,video {<br>border: 0;<br>margin: 0;<br>padding: 0;<br>vertical-align: baseline;<br>}3. Avoid padding with widthsWhen you add padding to an element with a width, it will end up much larger than what it should be. The width and the padding will be added together. So, if I have an element with the width of 100px, and I add a padding of 10px to that same element, then the awkward browser behavior will make that element 120px.To fix that, add this to everything that you do from now on: { -webkit-box-sizing: border-box; / Safari/Chrome, other WebKit /<br>-moz-box-sizing: border-box; / Firefox, other Gecko /<br>box-sizing: border-box; }4. Clear your floats, always!Make sure you clear your floats! If you don’t clear your floats, things will start acting weird. To learn more about how floats act on browsers, check out this article from Chris Coyier.To clear your floats, use this snippet of CSS:.parent-selector:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}If you wrap most of your elements, a really simple way would be to add this to your wrap class..wrap:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}Tada! Now your floats should be cleared.5. Test it out!Create your own cross-browser infrastructure or just use Endtest.If you make these things a habit, you will drastically eliminate 95% of your cross browser issues.I may be one of the last people you would expect to write an essay criticizing JavaScript, but here we are. Two of my primary areas of professional interest are JavaScript and “programming in the large.” I gave a presentation back in 2013 at mloc.js where I argued that static typing is an essential feature when picking a language for a large software project. For this reason, among others, I historically limited my use of Python to small projects with no more than a handful of files. Recently, I needed to build a command-line tool for work that could speak Thrift. I have been enjoying the Nuclide/Flow/Babel/ESLint toolchain a lot recently, so my first instinct was to use JavaScript for this new project, as well. However, it quickly became clear that if I went that route, I would have to spend a lot of time up front on getting the Thrift bindings to work properly. I couldn’t convince myself that my personal preference for JavaScript would justify such an investment, so I decided to take a look at Python. I was vaguely aware that there was an effort to add support for static typing in Python, so I Googled to find out what the state of the art was. It turns out that it is a tool named Mypy, and it provides gradual typing, much like Flow does for JavaScript or Hack does for PHP. Fortunately, Mypy is more like Hack+HHVM than it is like Flow in that a Python 3 runtime accepts the type annotations natively whereas Flow type annotations must be stripped by a separate tool before passing the code to a JavaScript runtime. (To use Mypy in Python 2, you have to put your type annotations in comments, operating in the style of the Google Closure toolchain.) Although Mypy does not appear to be as mature as Flow (support for incremental type checking is still in the works, for example), simply being able to succinctly document type information was enough to renew my interest in Python. In researching how to use Thrift from Python, a Google search turned up some sample Python code that spoke to Thrift using asynchronous abstractions. After gradual typing, async/await is the other feature in JavaScript that I cannot live without, so this code sample caught my attention! As we recently added support for building projects in Python 3.6 at work, it was trivial for me to get up and running with the latest and greatest features in Python. (Incidentally, I also learned that you really want Python 3.6, not 3.5, as 3.6 has some important improvements to Mypy, fixes to the <a href=\"https://bugs.python.org/issue28613\" data-href=\"https://bugs.python.org/issue28613\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">asyncio</a> API, literal string interpolation like you have in ES6, and more!) Coming from the era of “modern” JavaScript, one thing that was particularly refreshing was rediscovering how Python is an edit/refresh language out of the box whereas JavaScript used to be that way, but is no more. Let me explain what I mean by that:Indeed, the JavaScript ecosystem offers all sorts of tools to speed up this process using daemons and caching, but you or someone on your team has to invest quite a bit of time researching, assembling, and maintaining a JavaScript toolchain for your project before anyone can write a line of “modern” JavaScript. Although you may ultimately achieve a nice edit/refresh workflow, you certainly will not have one out of the box as you would in Python.Another refreshing difference between JavaScript and Python is the “batteries included” nature of Python. If you look at the standard library that comes with JavaScript, it is fairly minimal. The Node environment does a modest job of augmenting what is provided by the standard library, but the majority of the functionality you need inevitably has to be fetched from npm. Specifically, consider the following functionality that is included in Python’s standard library, but must be fetched from npm for a Node project:As you can see, for many of these features, there are multiple third-party libraries that provide overlapping functionality. (For example, if you were looking for a JSON parser, would you choose parse-json, safe-json-parse, fast-json-parse, jsonparse, or json-parser?) To make matters worse, npm module names are doled out on a first-come, first-serve basis. Much like domain names, this means that great names often go to undeserving projects. (For example, judging from its download count, the npm module named <a href=\"https://www.npmjs.com/package/logging\" data-href=\"https://www.npmjs.com/package/logging\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">logging</a> makes it one of the least popular logging packages for JavaScript.) This makes the comparison of third-party modules all the more time-consuming since the quality of the name is not a useful signal for the quality of the library. It might be possible that Python&#39;s third-party ecosystem is just as bad as npm&#39;s. What is impressive is that I have no idea whether that is the case because it is so rare that I have to look to a third-party Python package to get the functionality that I need. I am aware that data scientists rely heavily on third-party packages like NumPy, but unlike the Node ecosystem, there is one NumPy package that everyone uses rather than a litany of competitors named numpy-fast, numpy-plus, simple-numpy, etc.For me, one of the great ironies in all this is that, arguably, the presence of a strong standard library in JavaScript would be the most highly leveraged when compared to other programming languages. Why? Because today, every non-trivial web site requires you to download underscore.js or whatever its authors have chosen to use to compensate for JavaScript’s weak core. When you consider the aggregate adverse impact this has on network traffic and page load times, the numbers are frightening.No, no I am not. If you are building UI using web technologies (which is a lot of developers), then I still think that JavaScript is your best bet. Modulo the emergence of Web Assembly (which is worth paying attention to), JavaScript is still the only language that runs natively in the browser. There have been many attempts to take an existing programming language and compile it to JavaScript to avoid “having to” write JavaScript. There are cases where the results were good, but they never seemed to be great. Maybe some transpilation toolchain will ultimately succeed in unseating JavaScript as the language to write in for the web, but I suspect we’ll still have the majority of web developers writing JavaScript for quite some time. Additionally, the browser is not the only place where developers are building UI using web technologies. Two other prominent examples are Electron and React Native. Electron is attractive because it lets you write once for Windows, Mac, and Linux while React Native is attractive because it lets you write once for Android and iOS. Both are also empowering because the edit/refresh cycles using those tools is much faster than their native equivalents. From a hiring perspective, it seems like developers who know web technologies (1) are available in greater numbers than native developers, and (2) can support more platforms with smaller teams compared to native developers. Indeed, I could envision ways in which these platforms could be modified to support Python as the scripting language instead of JavaScript, which could change the calculus. However, one thing that all of the crazy tooling that exists in the JavaScript community has given way to is transpiler toolchains like Babel, which make it easier for ordinary developers (who do not have to be compiler hackers) to experiment with new JavaScript syntax. In particular, this tooling has paved the way for things like JSX, which I contend is one of the key features that makes React such an enjoyable technology for building UI. (Note that you can use React without JSX, but it is tedious.) To the best of my knowledge, the Python community does not have an equivalent, popular mechanism for experimenting with DSLs within Python. So although it might be straightforward to add Python bindings in these existing environments, I do not think that would be sufficient to get product developers to switch to Python unless changes were also made to the language that made it as easy to express UI code in Python as it is in JavaScript+JSX today.Python 3.6 has built-in support for gradual typing and async/await. Unlike JavaScript, this means that you can write Python code that uses these language features and run that file directly without any additional tooling. Further, its rich standard library means that you have to spend little time fishing around and evaluating third-party libraries to fill in missing gaps. It is very much a “get stuff done” server-side scripting language, requiring far less scaffolding than JavaScript to get a project off the ground. Although Mypy may not be as featureful or performant as Flow or TypeScript is today, the velocity of that project is certainly something that I am going to start paying attention to. By comparison, I expect that JavaScript will remain strong among product developers, but those who use Node today for server-side code or command-line tools would probably be better off using Python. If the Node community wants to resist this change, then I think they would benefit from (1) expanding the Node API to make it more comprehensive, and (2) reducing the startup time for Node. It would be even better if they could modify their runtime to recognize things like type annotations and JSX natively, though that would require changes to V8 (or Chakra, on Windows), which I expect would be difficult to maintain and/or upstream. Getting TC39 to standardize either of those language features (which would force Google/Microsoft’s hand to add native support in their JS runtimes) also seems like a tough sell. Overall, I am excited to see how things play out in both of these communities. You never know when someone will release a new technology that obsoletes your entire toolchain overnight. For all I know, we might wake up tomorrow and all decide that we should be writing OCaml. Better set your alarm clock.This post originally appeared on bolinfest.com."
  },
  {
    "link": "https://blog.meteor.com/mdg-acquires-kadira-apm-96dfb3167fe5?source=---------3-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/0*hvBdJ1pfegsqERrJ.jpg",
    "author": "John Howard",
    "date": "Mar 24",
    "photo": "https://cdn-images-1.medium.com/max/800/1*kDeTAI50LkwvhyoeHN-Rcg.png",
    "head": "MDG acquires Kadira APM",
    "contents": "There’s a certain kind of old-school, backend web developer who, a long time ago, mastered things like Perl or Python or PHP or Java Server Pages, maybe even Rails or Django. This person worked with giant relational databases and built APIs that serve up JSON and even (gasp!) XML.This person is a backend developer, so for a long time, JavaScript was just a fun little toy that added a bit of frontend trickery that could make things on a web page change color. If JavaScript was being really useful, it would add form validation that helped prevent the wrong information from getting into the database. Eight years ago jQuery blew this person’s mind. JavaScript itself was a language one merely tolerated, but never embraced.Then JavaScript and its modern frameworks ate backend, frontend, and everything in between, and it was time to re-become a web developer in 2017 — who writes JavaScript.Hi. I’m an ancient web developer who is learning modern JavaScript. I’ve just gotten started and I’m having a ball, but I’ve also got whiplash. There are a few things I wish I’d understood and accepted about the world of modern JavaScript before I got started.Here are some of the changes I had to make to my own mindset and expectations around learning a new ecosystem based on an old language which has taken over my craft.The modern JS world is nothing if not young and rapidly changing, so it’s easy to choose the framework or templating engine or build tool or tutorial that’s out of date or teaching a technique that’s no longer best practice (when there even is a generally-accepted notion of what “best practice” is).In those cases, it’s time to reach out to your Local Friendly Modern JavaScript Engineer, and have a little chat about the path you’re on. I’ve been lucky to get fantastic guidance from my fellow engineers here at Postlight (especially Jeremy Mack), and I thank them for putting up with my endless questions.The point is, learning modern JavaScript requires human intervention. Things haven’t settled down long enough for curriculums and guides to gel and mature, and for best practices to become authoritative for more than a few months. If you don’t have a human expert at hand, at the very least, check the date on that Medium article or tutorial or the last commit in that GitHub repository. If it’s more than a year old, it’s almost certainly not the way to go.Along these same lines: when you’re learning modern JavaScript, there’s a good chance that the solution to the problem you’re having is still getting worked out. In fact, it’s very possible it is only one code review away from getting merged into the package you’re using.When you’re working with an ancient language like PHP, you Google a question or problem, and almost 100% of the time you will find a 5-year-old Stack Overflow answer that solves it, or a full discussion in the (thorough, heavily commented, and unparalleled) documentation.Not so much with modern JavaScript. I’ve found myself trawling through comments on GitHub issues and source code only to find information that contradicts out-of-date documentation more than once. Parsing GitHub repos is part of learning and using various JavaScript packages, and for an Old Person like me, working that close to the edge can be bewildering.The other difficult thing about learning JavaScript in 2017: getting set up will feel like it takes you as long as building the app will. The sheer number of tools and plugins and packages and dependencies and editor setup and build configurations required to do it “the right way” is enough to stall you before you even get started.Do not let this stop you. I had to let go of doing it The Right Way from the get-go, and allow myself to fumble through using suboptimal or just plain amateur setups just to get comfortable with individual tools. (Let me tell you about that time I used nodemon to do my linting…) Then I’d find out better ways and incorporate what I could, when I could, on each new project.The JS world has a lot of work to do in this regard. Again, this area of modern JavaScript is a constantly moving target, but my Local Friendly Modern JS Engineers tell me that this tutorial from Jonathan Verrecchia is currently the definitive guide to building a modern JavaScript stack. For now.When you’re learning any new language, you write code and then you throw it away, and then you write some more. My modern JavaScript education has been a stepladder of tutorials, then a small tractable project during which I compiled a list of questions and problems, then a check-in with my coworkers to get answers and explanations, then more tutorials, then a slightly bigger project, more questions, a check-in — wash, rinse, repeat.Here’s an incomplete list of some of the workshops and tutorials I’ve run through in this process so far.From here I knew enough to get myself into all sorts of trouble, like experiment with Jest for testing, Botkit for more Slack bot fun, and Serverless to really hammer home the value of functional programming. If you don’t know what any of that means, that’s okay. It’s a big world, and we all take our own paths through it.Ultimately the most important thing I’ve had to remember is this: Doing is learning. Doing it badly? It’s still learning.Learning modern JavaScript these days can feel like a futile exercise in WTF. For those moments you’re wondering if you missed your calling as a barista, Google’s Addy Osmani has the right advice:Thanks to NodeSchool and Free Code Camp, two fantastic resources for beginners learning JavaScript.Browser compatibility issues can be frustrating, here’s how to avoid them:1. Prefix CSS3 stylesIf you’re using any type of modern CSS snippets, like box-sizing, or background-clip, just make sure that you use the appropriate vendor prefixes.-moz- / Firefox and other browsers using Mozilla&#39;s browser engine /<br>-webkit- / Safari, Chrome and browsers using the Webkit engine /<br>-o- / Opera /<br>-ms- / Internet Explorer (but not always) /2. Use a resetYou can use normalize.css or just a simple reset found anywhere on the net. Here’s the one I use and it’s from the Genesis Framework Style Sheet.html,body,div,span,applet,object,iframe,h1,h2,<br>h3,h4,h5,h6,p,blockquote,a,abbr,acronym,address,<br>big,cite,del,dfn,em,img,ins,kbd,q,s,samp,small,<br>strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,<br>dd,ol,ul,li,fieldset,form,label,legend,table,caption,<br>tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,<br>embed,figure,figcaption,footer,header,hgroup,input,menu,<br>nav,output,ruby,section,summary,time,mark,audio,video {<br>border: 0;<br>margin: 0;<br>padding: 0;<br>vertical-align: baseline;<br>}3. Avoid padding with widthsWhen you add padding to an element with a width, it will end up much larger than what it should be. The width and the padding will be added together. So, if I have an element with the width of 100px, and I add a padding of 10px to that same element, then the awkward browser behavior will make that element 120px.To fix that, add this to everything that you do from now on: { -webkit-box-sizing: border-box; / Safari/Chrome, other WebKit /<br>-moz-box-sizing: border-box; / Firefox, other Gecko /<br>box-sizing: border-box; }4. Clear your floats, always!Make sure you clear your floats! If you don’t clear your floats, things will start acting weird. To learn more about how floats act on browsers, check out this article from Chris Coyier.To clear your floats, use this snippet of CSS:.parent-selector:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}If you wrap most of your elements, a really simple way would be to add this to your wrap class..wrap:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}Tada! Now your floats should be cleared.5. Test it out!Create your own cross-browser infrastructure or just use Endtest.If you make these things a habit, you will drastically eliminate 95% of your cross browser issues.I may be one of the last people you would expect to write an essay criticizing JavaScript, but here we are. Two of my primary areas of professional interest are JavaScript and “programming in the large.” I gave a presentation back in 2013 at mloc.js where I argued that static typing is an essential feature when picking a language for a large software project. For this reason, among others, I historically limited my use of Python to small projects with no more than a handful of files. Recently, I needed to build a command-line tool for work that could speak Thrift. I have been enjoying the Nuclide/Flow/Babel/ESLint toolchain a lot recently, so my first instinct was to use JavaScript for this new project, as well. However, it quickly became clear that if I went that route, I would have to spend a lot of time up front on getting the Thrift bindings to work properly. I couldn’t convince myself that my personal preference for JavaScript would justify such an investment, so I decided to take a look at Python. I was vaguely aware that there was an effort to add support for static typing in Python, so I Googled to find out what the state of the art was. It turns out that it is a tool named Mypy, and it provides gradual typing, much like Flow does for JavaScript or Hack does for PHP. Fortunately, Mypy is more like Hack+HHVM than it is like Flow in that a Python 3 runtime accepts the type annotations natively whereas Flow type annotations must be stripped by a separate tool before passing the code to a JavaScript runtime. (To use Mypy in Python 2, you have to put your type annotations in comments, operating in the style of the Google Closure toolchain.) Although Mypy does not appear to be as mature as Flow (support for incremental type checking is still in the works, for example), simply being able to succinctly document type information was enough to renew my interest in Python. In researching how to use Thrift from Python, a Google search turned up some sample Python code that spoke to Thrift using asynchronous abstractions. After gradual typing, async/await is the other feature in JavaScript that I cannot live without, so this code sample caught my attention! As we recently added support for building projects in Python 3.6 at work, it was trivial for me to get up and running with the latest and greatest features in Python. (Incidentally, I also learned that you really want Python 3.6, not 3.5, as 3.6 has some important improvements to Mypy, fixes to the <a href=\"https://bugs.python.org/issue28613\" data-href=\"https://bugs.python.org/issue28613\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">asyncio</a> API, literal string interpolation like you have in ES6, and more!) Coming from the era of “modern” JavaScript, one thing that was particularly refreshing was rediscovering how Python is an edit/refresh language out of the box whereas JavaScript used to be that way, but is no more. Let me explain what I mean by that:Indeed, the JavaScript ecosystem offers all sorts of tools to speed up this process using daemons and caching, but you or someone on your team has to invest quite a bit of time researching, assembling, and maintaining a JavaScript toolchain for your project before anyone can write a line of “modern” JavaScript. Although you may ultimately achieve a nice edit/refresh workflow, you certainly will not have one out of the box as you would in Python.Another refreshing difference between JavaScript and Python is the “batteries included” nature of Python. If you look at the standard library that comes with JavaScript, it is fairly minimal. The Node environment does a modest job of augmenting what is provided by the standard library, but the majority of the functionality you need inevitably has to be fetched from npm. Specifically, consider the following functionality that is included in Python’s standard library, but must be fetched from npm for a Node project:As you can see, for many of these features, there are multiple third-party libraries that provide overlapping functionality. (For example, if you were looking for a JSON parser, would you choose parse-json, safe-json-parse, fast-json-parse, jsonparse, or json-parser?) To make matters worse, npm module names are doled out on a first-come, first-serve basis. Much like domain names, this means that great names often go to undeserving projects. (For example, judging from its download count, the npm module named <a href=\"https://www.npmjs.com/package/logging\" data-href=\"https://www.npmjs.com/package/logging\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">logging</a> makes it one of the least popular logging packages for JavaScript.) This makes the comparison of third-party modules all the more time-consuming since the quality of the name is not a useful signal for the quality of the library. It might be possible that Python&#39;s third-party ecosystem is just as bad as npm&#39;s. What is impressive is that I have no idea whether that is the case because it is so rare that I have to look to a third-party Python package to get the functionality that I need. I am aware that data scientists rely heavily on third-party packages like NumPy, but unlike the Node ecosystem, there is one NumPy package that everyone uses rather than a litany of competitors named numpy-fast, numpy-plus, simple-numpy, etc.For me, one of the great ironies in all this is that, arguably, the presence of a strong standard library in JavaScript would be the most highly leveraged when compared to other programming languages. Why? Because today, every non-trivial web site requires you to download underscore.js or whatever its authors have chosen to use to compensate for JavaScript’s weak core. When you consider the aggregate adverse impact this has on network traffic and page load times, the numbers are frightening.No, no I am not. If you are building UI using web technologies (which is a lot of developers), then I still think that JavaScript is your best bet. Modulo the emergence of Web Assembly (which is worth paying attention to), JavaScript is still the only language that runs natively in the browser. There have been many attempts to take an existing programming language and compile it to JavaScript to avoid “having to” write JavaScript. There are cases where the results were good, but they never seemed to be great. Maybe some transpilation toolchain will ultimately succeed in unseating JavaScript as the language to write in for the web, but I suspect we’ll still have the majority of web developers writing JavaScript for quite some time. Additionally, the browser is not the only place where developers are building UI using web technologies. Two other prominent examples are Electron and React Native. Electron is attractive because it lets you write once for Windows, Mac, and Linux while React Native is attractive because it lets you write once for Android and iOS. Both are also empowering because the edit/refresh cycles using those tools is much faster than their native equivalents. From a hiring perspective, it seems like developers who know web technologies (1) are available in greater numbers than native developers, and (2) can support more platforms with smaller teams compared to native developers. Indeed, I could envision ways in which these platforms could be modified to support Python as the scripting language instead of JavaScript, which could change the calculus. However, one thing that all of the crazy tooling that exists in the JavaScript community has given way to is transpiler toolchains like Babel, which make it easier for ordinary developers (who do not have to be compiler hackers) to experiment with new JavaScript syntax. In particular, this tooling has paved the way for things like JSX, which I contend is one of the key features that makes React such an enjoyable technology for building UI. (Note that you can use React without JSX, but it is tedious.) To the best of my knowledge, the Python community does not have an equivalent, popular mechanism for experimenting with DSLs within Python. So although it might be straightforward to add Python bindings in these existing environments, I do not think that would be sufficient to get product developers to switch to Python unless changes were also made to the language that made it as easy to express UI code in Python as it is in JavaScript+JSX today.Python 3.6 has built-in support for gradual typing and async/await. Unlike JavaScript, this means that you can write Python code that uses these language features and run that file directly without any additional tooling. Further, its rich standard library means that you have to spend little time fishing around and evaluating third-party libraries to fill in missing gaps. It is very much a “get stuff done” server-side scripting language, requiring far less scaffolding than JavaScript to get a project off the ground. Although Mypy may not be as featureful or performant as Flow or TypeScript is today, the velocity of that project is certainly something that I am going to start paying attention to. By comparison, I expect that JavaScript will remain strong among product developers, but those who use Node today for server-side code or command-line tools would probably be better off using Python. If the Node community wants to resist this change, then I think they would benefit from (1) expanding the Node API to make it more comprehensive, and (2) reducing the startup time for Node. It would be even better if they could modify their runtime to recognize things like type annotations and JSX natively, though that would require changes to V8 (or Chakra, on Windows), which I expect would be difficult to maintain and/or upstream. Getting TC39 to standardize either of those language features (which would force Google/Microsoft’s hand to add native support in their JS runtimes) also seems like a tough sell. Overall, I am excited to see how things play out in both of these communities. You never know when someone will release a new technology that obsoletes your entire toolchain overnight. For all I know, we might wake up tomorrow and all decide that we should be writing OCaml. Better set your alarm clock.This post originally appeared on bolinfest.com.I’m excited to announce that Meteor Development Group has signed a definitive agreement to acquire the Kadira APM product.Since Arunoda’s announcement last December that Kadira would be shutting down, we’ve explored a number of options to ensure continuity and a bright future for Meteor’s best application performance tool. Unsurprisingly, many Meteor developers have told us that Kadira is the most valuable tool they use to scale, tune, and analyze their apps. I’m delighted where we’ve landed — bringing Kadira APM under the MDG umbrella makes a lot of sense as part of our commitment to the Meteor platform and developer community.We’re working closely now with Arunoda and a number of Kadira customers. If you’d like to get early access to our efforts, please let us know. In the coming weeks, we’ll open things up to everyone and organize a transition off the old Kadira system.I hope you’re as excited as we are. This agreement puts Meteor APM on solid footing, lets us respond even faster to customer requests, and opens up many opportunities for us to coordinate improvements across Meteor, Galaxy, and Kadira that help teams with critical applications in production.Stay tuned as there will be more to share soon."
  },
  {
    "link": "https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318?source=---------4-----------",
    "pic": "https://cdn-images-1.medium.com/fit/c/36/36/1*64H5DfQ6_WwZ0WbsY430dA.jpeg",
    "author": "",
    "date": "Mar 25",
    "photo": "https://cdn-images-1.medium.com/max/600/1*BGLLxCDDczXd9hxO47eTcw.png",
    "head": "webpack bits: Getting the most out of the CommonsChunkPlugin()",
    "contents": "There’s a certain kind of old-school, backend web developer who, a long time ago, mastered things like Perl or Python or PHP or Java Server Pages, maybe even Rails or Django. This person worked with giant relational databases and built APIs that serve up JSON and even (gasp!) XML.This person is a backend developer, so for a long time, JavaScript was just a fun little toy that added a bit of frontend trickery that could make things on a web page change color. If JavaScript was being really useful, it would add form validation that helped prevent the wrong information from getting into the database. Eight years ago jQuery blew this person’s mind. JavaScript itself was a language one merely tolerated, but never embraced.Then JavaScript and its modern frameworks ate backend, frontend, and everything in between, and it was time to re-become a web developer in 2017 — who writes JavaScript.Hi. I’m an ancient web developer who is learning modern JavaScript. I’ve just gotten started and I’m having a ball, but I’ve also got whiplash. There are a few things I wish I’d understood and accepted about the world of modern JavaScript before I got started.Here are some of the changes I had to make to my own mindset and expectations around learning a new ecosystem based on an old language which has taken over my craft.The modern JS world is nothing if not young and rapidly changing, so it’s easy to choose the framework or templating engine or build tool or tutorial that’s out of date or teaching a technique that’s no longer best practice (when there even is a generally-accepted notion of what “best practice” is).In those cases, it’s time to reach out to your Local Friendly Modern JavaScript Engineer, and have a little chat about the path you’re on. I’ve been lucky to get fantastic guidance from my fellow engineers here at Postlight (especially Jeremy Mack), and I thank them for putting up with my endless questions.The point is, learning modern JavaScript requires human intervention. Things haven’t settled down long enough for curriculums and guides to gel and mature, and for best practices to become authoritative for more than a few months. If you don’t have a human expert at hand, at the very least, check the date on that Medium article or tutorial or the last commit in that GitHub repository. If it’s more than a year old, it’s almost certainly not the way to go.Along these same lines: when you’re learning modern JavaScript, there’s a good chance that the solution to the problem you’re having is still getting worked out. In fact, it’s very possible it is only one code review away from getting merged into the package you’re using.When you’re working with an ancient language like PHP, you Google a question or problem, and almost 100% of the time you will find a 5-year-old Stack Overflow answer that solves it, or a full discussion in the (thorough, heavily commented, and unparalleled) documentation.Not so much with modern JavaScript. I’ve found myself trawling through comments on GitHub issues and source code only to find information that contradicts out-of-date documentation more than once. Parsing GitHub repos is part of learning and using various JavaScript packages, and for an Old Person like me, working that close to the edge can be bewildering.The other difficult thing about learning JavaScript in 2017: getting set up will feel like it takes you as long as building the app will. The sheer number of tools and plugins and packages and dependencies and editor setup and build configurations required to do it “the right way” is enough to stall you before you even get started.Do not let this stop you. I had to let go of doing it The Right Way from the get-go, and allow myself to fumble through using suboptimal or just plain amateur setups just to get comfortable with individual tools. (Let me tell you about that time I used nodemon to do my linting…) Then I’d find out better ways and incorporate what I could, when I could, on each new project.The JS world has a lot of work to do in this regard. Again, this area of modern JavaScript is a constantly moving target, but my Local Friendly Modern JS Engineers tell me that this tutorial from Jonathan Verrecchia is currently the definitive guide to building a modern JavaScript stack. For now.When you’re learning any new language, you write code and then you throw it away, and then you write some more. My modern JavaScript education has been a stepladder of tutorials, then a small tractable project during which I compiled a list of questions and problems, then a check-in with my coworkers to get answers and explanations, then more tutorials, then a slightly bigger project, more questions, a check-in — wash, rinse, repeat.Here’s an incomplete list of some of the workshops and tutorials I’ve run through in this process so far.From here I knew enough to get myself into all sorts of trouble, like experiment with Jest for testing, Botkit for more Slack bot fun, and Serverless to really hammer home the value of functional programming. If you don’t know what any of that means, that’s okay. It’s a big world, and we all take our own paths through it.Ultimately the most important thing I’ve had to remember is this: Doing is learning. Doing it badly? It’s still learning.Learning modern JavaScript these days can feel like a futile exercise in WTF. For those moments you’re wondering if you missed your calling as a barista, Google’s Addy Osmani has the right advice:Thanks to NodeSchool and Free Code Camp, two fantastic resources for beginners learning JavaScript.Browser compatibility issues can be frustrating, here’s how to avoid them:1. Prefix CSS3 stylesIf you’re using any type of modern CSS snippets, like box-sizing, or background-clip, just make sure that you use the appropriate vendor prefixes.-moz- / Firefox and other browsers using Mozilla&#39;s browser engine /<br>-webkit- / Safari, Chrome and browsers using the Webkit engine /<br>-o- / Opera /<br>-ms- / Internet Explorer (but not always) /2. Use a resetYou can use normalize.css or just a simple reset found anywhere on the net. Here’s the one I use and it’s from the Genesis Framework Style Sheet.html,body,div,span,applet,object,iframe,h1,h2,<br>h3,h4,h5,h6,p,blockquote,a,abbr,acronym,address,<br>big,cite,del,dfn,em,img,ins,kbd,q,s,samp,small,<br>strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,<br>dd,ol,ul,li,fieldset,form,label,legend,table,caption,<br>tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,<br>embed,figure,figcaption,footer,header,hgroup,input,menu,<br>nav,output,ruby,section,summary,time,mark,audio,video {<br>border: 0;<br>margin: 0;<br>padding: 0;<br>vertical-align: baseline;<br>}3. Avoid padding with widthsWhen you add padding to an element with a width, it will end up much larger than what it should be. The width and the padding will be added together. So, if I have an element with the width of 100px, and I add a padding of 10px to that same element, then the awkward browser behavior will make that element 120px.To fix that, add this to everything that you do from now on: { -webkit-box-sizing: border-box; / Safari/Chrome, other WebKit /<br>-moz-box-sizing: border-box; / Firefox, other Gecko /<br>box-sizing: border-box; }4. Clear your floats, always!Make sure you clear your floats! If you don’t clear your floats, things will start acting weird. To learn more about how floats act on browsers, check out this article from Chris Coyier.To clear your floats, use this snippet of CSS:.parent-selector:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}If you wrap most of your elements, a really simple way would be to add this to your wrap class..wrap:after {<br>content: &quot;&quot;;<br>display: table;<br>clear: both;<br>}Tada! Now your floats should be cleared.5. Test it out!Create your own cross-browser infrastructure or just use Endtest.If you make these things a habit, you will drastically eliminate 95% of your cross browser issues.I may be one of the last people you would expect to write an essay criticizing JavaScript, but here we are. Two of my primary areas of professional interest are JavaScript and “programming in the large.” I gave a presentation back in 2013 at mloc.js where I argued that static typing is an essential feature when picking a language for a large software project. For this reason, among others, I historically limited my use of Python to small projects with no more than a handful of files. Recently, I needed to build a command-line tool for work that could speak Thrift. I have been enjoying the Nuclide/Flow/Babel/ESLint toolchain a lot recently, so my first instinct was to use JavaScript for this new project, as well. However, it quickly became clear that if I went that route, I would have to spend a lot of time up front on getting the Thrift bindings to work properly. I couldn’t convince myself that my personal preference for JavaScript would justify such an investment, so I decided to take a look at Python. I was vaguely aware that there was an effort to add support for static typing in Python, so I Googled to find out what the state of the art was. It turns out that it is a tool named Mypy, and it provides gradual typing, much like Flow does for JavaScript or Hack does for PHP. Fortunately, Mypy is more like Hack+HHVM than it is like Flow in that a Python 3 runtime accepts the type annotations natively whereas Flow type annotations must be stripped by a separate tool before passing the code to a JavaScript runtime. (To use Mypy in Python 2, you have to put your type annotations in comments, operating in the style of the Google Closure toolchain.) Although Mypy does not appear to be as mature as Flow (support for incremental type checking is still in the works, for example), simply being able to succinctly document type information was enough to renew my interest in Python. In researching how to use Thrift from Python, a Google search turned up some sample Python code that spoke to Thrift using asynchronous abstractions. After gradual typing, async/await is the other feature in JavaScript that I cannot live without, so this code sample caught my attention! As we recently added support for building projects in Python 3.6 at work, it was trivial for me to get up and running with the latest and greatest features in Python. (Incidentally, I also learned that you really want Python 3.6, not 3.5, as 3.6 has some important improvements to Mypy, fixes to the <a href=\"https://bugs.python.org/issue28613\" data-href=\"https://bugs.python.org/issue28613\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">asyncio</a> API, literal string interpolation like you have in ES6, and more!) Coming from the era of “modern” JavaScript, one thing that was particularly refreshing was rediscovering how Python is an edit/refresh language out of the box whereas JavaScript used to be that way, but is no more. Let me explain what I mean by that:Indeed, the JavaScript ecosystem offers all sorts of tools to speed up this process using daemons and caching, but you or someone on your team has to invest quite a bit of time researching, assembling, and maintaining a JavaScript toolchain for your project before anyone can write a line of “modern” JavaScript. Although you may ultimately achieve a nice edit/refresh workflow, you certainly will not have one out of the box as you would in Python.Another refreshing difference between JavaScript and Python is the “batteries included” nature of Python. If you look at the standard library that comes with JavaScript, it is fairly minimal. The Node environment does a modest job of augmenting what is provided by the standard library, but the majority of the functionality you need inevitably has to be fetched from npm. Specifically, consider the following functionality that is included in Python’s standard library, but must be fetched from npm for a Node project:As you can see, for many of these features, there are multiple third-party libraries that provide overlapping functionality. (For example, if you were looking for a JSON parser, would you choose parse-json, safe-json-parse, fast-json-parse, jsonparse, or json-parser?) To make matters worse, npm module names are doled out on a first-come, first-serve basis. Much like domain names, this means that great names often go to undeserving projects. (For example, judging from its download count, the npm module named <a href=\"https://www.npmjs.com/package/logging\" data-href=\"https://www.npmjs.com/package/logging\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener\" target=\"_blank\">logging</a> makes it one of the least popular logging packages for JavaScript.) This makes the comparison of third-party modules all the more time-consuming since the quality of the name is not a useful signal for the quality of the library. It might be possible that Python&#39;s third-party ecosystem is just as bad as npm&#39;s. What is impressive is that I have no idea whether that is the case because it is so rare that I have to look to a third-party Python package to get the functionality that I need. I am aware that data scientists rely heavily on third-party packages like NumPy, but unlike the Node ecosystem, there is one NumPy package that everyone uses rather than a litany of competitors named numpy-fast, numpy-plus, simple-numpy, etc.For me, one of the great ironies in all this is that, arguably, the presence of a strong standard library in JavaScript would be the most highly leveraged when compared to other programming languages. Why? Because today, every non-trivial web site requires you to download underscore.js or whatever its authors have chosen to use to compensate for JavaScript’s weak core. When you consider the aggregate adverse impact this has on network traffic and page load times, the numbers are frightening.No, no I am not. If you are building UI using web technologies (which is a lot of developers), then I still think that JavaScript is your best bet. Modulo the emergence of Web Assembly (which is worth paying attention to), JavaScript is still the only language that runs natively in the browser. There have been many attempts to take an existing programming language and compile it to JavaScript to avoid “having to” write JavaScript. There are cases where the results were good, but they never seemed to be great. Maybe some transpilation toolchain will ultimately succeed in unseating JavaScript as the language to write in for the web, but I suspect we’ll still have the majority of web developers writing JavaScript for quite some time. Additionally, the browser is not the only place where developers are building UI using web technologies. Two other prominent examples are Electron and React Native. Electron is attractive because it lets you write once for Windows, Mac, and Linux while React Native is attractive because it lets you write once for Android and iOS. Both are also empowering because the edit/refresh cycles using those tools is much faster than their native equivalents. From a hiring perspective, it seems like developers who know web technologies (1) are available in greater numbers than native developers, and (2) can support more platforms with smaller teams compared to native developers. Indeed, I could envision ways in which these platforms could be modified to support Python as the scripting language instead of JavaScript, which could change the calculus. However, one thing that all of the crazy tooling that exists in the JavaScript community has given way to is transpiler toolchains like Babel, which make it easier for ordinary developers (who do not have to be compiler hackers) to experiment with new JavaScript syntax. In particular, this tooling has paved the way for things like JSX, which I contend is one of the key features that makes React such an enjoyable technology for building UI. (Note that you can use React without JSX, but it is tedious.) To the best of my knowledge, the Python community does not have an equivalent, popular mechanism for experimenting with DSLs within Python. So although it might be straightforward to add Python bindings in these existing environments, I do not think that would be sufficient to get product developers to switch to Python unless changes were also made to the language that made it as easy to express UI code in Python as it is in JavaScript+JSX today.Python 3.6 has built-in support for gradual typing and async/await. Unlike JavaScript, this means that you can write Python code that uses these language features and run that file directly without any additional tooling. Further, its rich standard library means that you have to spend little time fishing around and evaluating third-party libraries to fill in missing gaps. It is very much a “get stuff done” server-side scripting language, requiring far less scaffolding than JavaScript to get a project off the ground. Although Mypy may not be as featureful or performant as Flow or TypeScript is today, the velocity of that project is certainly something that I am going to start paying attention to. By comparison, I expect that JavaScript will remain strong among product developers, but those who use Node today for server-side code or command-line tools would probably be better off using Python. If the Node community wants to resist this change, then I think they would benefit from (1) expanding the Node API to make it more comprehensive, and (2) reducing the startup time for Node. It would be even better if they could modify their runtime to recognize things like type annotations and JSX natively, though that would require changes to V8 (or Chakra, on Windows), which I expect would be difficult to maintain and/or upstream. Getting TC39 to standardize either of those language features (which would force Google/Microsoft’s hand to add native support in their JS runtimes) also seems like a tough sell. Overall, I am excited to see how things play out in both of these communities. You never know when someone will release a new technology that obsoletes your entire toolchain overnight. For all I know, we might wake up tomorrow and all decide that we should be writing OCaml. Better set your alarm clock.This post originally appeared on bolinfest.com.I’m excited to announce that Meteor Development Group has signed a definitive agreement to acquire the Kadira APM product.Since Arunoda’s announcement last December that Kadira would be shutting down, we’ve explored a number of options to ensure continuity and a bright future for Meteor’s best application performance tool. Unsurprisingly, many Meteor developers have told us that Kadira is the most valuable tool they use to scale, tune, and analyze their apps. I’m delighted where we’ve landed — bringing Kadira APM under the MDG umbrella makes a lot of sense as part of our commitment to the Meteor platform and developer community.We’re working closely now with Arunoda and a number of Kadira customers. If you’d like to get early access to our efforts, please let us know. In the coming weeks, we’ll open things up to everyone and organize a transition off the old Kadira system.I hope you’re as excited as we are. This agreement puts Meteor APM on solid footing, lets us respond even faster to customer requests, and opens up many opportunities for us to coordinate improvements across Meteor, Galaxy, and Kadira that help teams with critical applications in production.Stay tuned as there will be more to share soon.From time to time, the webpack core team loves to get the community involved on Twitter, and share bits and pieces of knowledge in a fun and informative way.This time, the “rules to the game” were simple. Install webpack-bundle-analyzer, generate a fancy colorful image of all of your bundles, and share it with me. In return, the webpack team offered to help identify any potential issues we could spot!The most common theme was code duplication: Libraries, components, code was duplicated across multiple [sync or async] bundles!Swizec Teller was kind enough to share one of his builds (which in fact is built for over 8–9 standalone single-page applications ). I chose this example out of all of them because there so many great techniques we can identify from it. So lets look at this in more detail:We can infer quite a few things from this (without looking at the actual configuration).Each single-page app is using a new CommonsChunkPlugin that targets just that entry point, and its vendor code. This creates a bundle with only modules that come from node_modules folder, and another bundle with just application code. The configuration portion was even provided:The activeApps variable most likely represents each of the individual entry points.Below are a few areas that I circled that could use some improvement.What we see above is many large libraries like momentjs, lodash, and jquery being used across 6 or more vendor bundles. The strategy for adding all vendors into a separate bundle is good, but we should also apply that same strategy across all vendor bundles.I suggested that Swizec add the following at the end of his plugins array:What we are telling webpack is the following:As you can see now, all of those modules were extracted into a separate file, and on top of that, Swizec reported that this decreased overall application sizes by 17%!So this amount of duplication wasn’t as severe in terms of overall code size, however, when you look at the full size image below, you can see the exact same 3 modules across every async chunk.As you can see above, the same 2–3 components are used across all 40–50 async bundles. So how do we solve this with CommonsChunkPlugin?The technique will be very similar to the first, however we will need to set the async property in the configuration option, to true as seen below:In the same way — webpack will scan all chunks and look for common modules. Since async: true, only code split bundles will be scanned. Because we did not specify minChunks the value defaults to 3. So what webpack is being told is:Here is what the result was:Now the async chunks are extremely tiny, and all of that code has been aggregated into one file called commonlazy.js . Since these bundle were already pretty tiny, the size impact wasn’t very noticeable until second visit. Now there is far less data being shipped per code split bundle and we are saving users load time and data consumption by placing those common modules into a separate cacheable chunk.So what if you want to have more control? There are scenarios where you don’t want to have a single shared bundle because not every lazy/entry chunk may use it. The minChunks property also takes a function!! This can be your “filtering predicate” for what modules are added to your newly created bundle. Below are examples ofThe example above says:You could apply this same behavior to async bundles by setting `async: true` also!With this minChunks you can create smaller subsets of cacheable vendors for specific entries and bundles. In the end, you may wind up with something that looks like this:CommonsChunkPlugin() may be powerful, but keep in mind that each one of these examples is tailored to the application it is applied to. So before you copy-pasta these snippets in, take advice from Sam Saccone and Paul Irish and MPDIA first to make sure you apply the right solution.These are just a sampling of options and uses for CommonsChunkPlugin(). To find more, check out our <a href=\"https://github.com/webpack/webpack/tree/master/examples\" data-href=\"https://github.com/webpack/webpack/tree/master/examples\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">/examples</a> directory in our webpack/webpack core GitHub repo! If you have a great idea for more, feel free and submit a Pull Request!No time to help contribute? Want to give back in other ways? Become a Backer or Sponsor to webpack by donating to our open collective. Open Collective not only helps support the Core Team, but also supports contributors who have spent significant time improving our organization on their free time! ❤"
  }
]